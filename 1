local UILibrary = loadstring(game:HttpGet("https://pastebin.com/raw/V1ca2q9s"))()

local MainUI = UILibrary.Load("SNooBeHub")
local FirstPage = MainUI.AddPage("Home & Admin")
local FirstLabel = FirstPage.AddLabel("Welcome To My Hub :)..")

local FirstButton = FirstPage.AddButton("Refresh", function()
local args = {
        [1] = ";re"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))    
end)

local FirstButton = FirstPage.AddButton("R6", function()
    local args = {
        [1] = ";morph me Slender "
    }
    
    game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait()
    local args = {
    [1] = ";morph me Noob1 "
    }
    
    game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(0)
    local args = {
    [1] = ";char me nato1231231Qw"
    }
    
    game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
end)

local FirstLabel = FirstPage.AddLabel("Admin")

local FirstButton = FirstPage.AddButton("Infinite yield", function()
loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
end)

local FirstButton = FirstPage.AddButton("iv admin", function()
loadstring(game:HttpGet('https://raw.githubusercontent.com/BloodyBurns/Hexx/main/Iv%20Admin/Admin%202.lua'))()
end)

local FirstButton = FirstPage.AddButton("Fates Admin", function()
loadstring(game:HttpGet('https://raw.githubusercontent.com/qqc4/2/main/2'))()
end)

local FirstPage = MainUI.AddPage("My Scripts")
local FirstLabel = FirstPage.AddLabel("My Animations")

local FirstButton = FirstPage.AddButton("Animation (Only R6)", function()
    local args = {
        [1] = ";morph me Slender "
    }
    
    game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait()
    local args = {
    [1] = ";morph me Noob1 "
    }
    
    game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(0)
    local args = {
    [1] = ";char me nato1231231Qw"
    }
    
    game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
wait(.5)
if "myworld reanimate again" then
    --reanimate by MyWorld#4430 discord.gg/pYVHtSJmEY
    local Vector3_101 = Vector3.new(1, 0, 1)
    local netless_Y = Vector3.new(0, 25.1, 0)
    local function getNetlessVelocity(realPartVelocity) --change this if you have a better method
        local mag = realPartVelocity.Magnitude
        if (mag > 1) and (mag < 100) then
            local unit = realPartVelocity.Unit
            if (unit.Y > 0.7) or (unit.Y < -0.7) then
                return realPartVelocity * (25.1 / realPartVelocity.Y)
            end
            realPartVelocity = unit * 100
        end
        return (realPartVelocity * Vector3_101) + netless_Y
    end
    local simradius = "shp" --simulation radius (net bypass) method
    --"shp" - sethiddenproperty
    --"ssr" - setsimulationradius
    --false - disable
    local noclipAllParts = false --set it to true if you want noclip
    local flingpart = "HumanoidRootPart" --the part that will be used to fling (ctrl + F "fling function")
    local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
    local newanimate = true --disables the animate script and enables after reanimation
    local discharscripts = true --disables all localScripts parented to your character before reanimation
    local R15toR6 = true --tries to convert your character to r6 if its r15
    local hatcollide = false --makes hats cancollide (credit to ShownApe) (works only with reanimate method 0)
    local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
    local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
    local hedafterneck = true --disable aligns for head and enable after neck or torso is removed
    local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
    local method = 3 --reanimation method
    --methods:
    --0 - breakJoints (takes [loadtime] seconds to laod)
    --1 - limbs
    --2 - limbs + anti respawn
    --3 - limbs + breakJoints after [loadtime] seconds
    --4 - remove humanoid + breakJoints
    --5 - remove humanoid + limbs
    local alignmode = 2 --AlignPosition mode
    --modes:
    --1 - AlignPosition rigidity enabled true
    --2 - 2 AlignPositions rigidity enabled both true and false
    --3 - AlignPosition rigidity enabled false
    
    local lp = game:GetService("Players").LocalPlayer
    local rs = game:GetService("RunService")
    local stepped = rs.Stepped
    local heartbeat = rs.Heartbeat
    local renderstepped = rs.RenderStepped
    local sg = game:GetService("StarterGui")
    local ws = game:GetService("Workspace")
    local cf = CFrame.new
    local v3 = Vector3.new
    local v3_0 = Vector3.zero
    local inf = math.huge
    
    local c = lp.Character
    
    if not (c and c.Parent) then
    	return
    end
    
    c:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (c and c.Parent) then
    	    c = nil
    	end
    end)
    
    local function gp(parent, name, className)
    	if typeof(parent) == "Instance" then
    		for i, v in pairs(parent:GetChildren()) do
    			if (v.Name == name) and v:IsA(className) then
    				return v
    			end
    		end
    	end
    	return nil
    end
    
    if type(getNetlessVelocity) ~= "function" then
        getNetlessVelocity = nil
    end
    
    local function align(Part0, Part1)
    	Part0.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
    
    	local att0 = Instance.new("Attachment")
    	att0.Orientation = v3_0
    	att0.Position = v3_0
    	att0.Name = "att0_" .. Part0.Name
    	local att1 = Instance.new("Attachment")
    	att1.Orientation = v3_0
    	att1.Position = v3_0
    	att1.Name = "att1_" .. Part1.Name
    
    	if (alignmode == 1) or (alignmode == 2) then
    		local ape = Instance.new("AlignPosition", att0)
    		ape.ApplyAtCenterOfMass = false
    		ape.MaxForce = inf
    		ape.MaxVelocity = inf
    		ape.ReactionForceEnabled = false
    		ape.Responsiveness = 200
    		ape.Attachment1 = att1
    		ape.Attachment0 = att0
    		ape.Name = "AlignPositionRtrue"
    		ape.RigidityEnabled = true
    	end
    
    	if (alignmode == 2) or (alignmode == 3) then
    		local apd = Instance.new("AlignPosition", att0)
    		apd.ApplyAtCenterOfMass = false
    		apd.MaxForce = inf
    		apd.MaxVelocity = inf
    		apd.ReactionForceEnabled = false
    		apd.Responsiveness = 200
    		apd.Attachment1 = att1
    		apd.Attachment0 = att0
    		apd.Name = "AlignPositionRfalse"
    		apd.RigidityEnabled = false
    	end
    
    	local ao = Instance.new("AlignOrientation", att0)
    	ao.MaxAngularVelocity = inf
    	ao.MaxTorque = inf
    	ao.PrimaryAxisOnly = false
    	ao.ReactionTorqueEnabled = false
    	ao.Responsiveness = 200
    	ao.Attachment1 = att1
    	ao.Attachment0 = att0
    	ao.RigidityEnabled = false
    
    	if getNetlessVelocity then
    	    local vel = Part0.Velocity
    	    local velpart = Part1
            local rsteppedcon = renderstepped:Connect(function()
                Part0.Velocity = vel
            end)
            local heartbeatcon = heartbeat:Connect(function()
                vel = Part0.Velocity
                Part0.Velocity = getNetlessVelocity(velpart.Velocity)
            end)
            local attcon = nil
            Part0:GetPropertyChangedSignal("Parent"):Connect(function()
                if not (Part0 and Part0.Parent) then
                    rsteppedcon:Disconnect()
                    heartbeatcon:Disconnect()
                    attcon:Disconnect()
                end
            end)
            attcon = att1:GetPropertyChangedSignal("Parent"):Connect(function()
    	        if not (att1 and att1.Parent) then
    	            attcon:Disconnect()
                    velpart = Part0
    	        else
    	            velpart = att1.Parent
    	            if not velpart:IsA("BasePart") then
    	                velpart = Part0
    	            end
    	        end
    	    end)
    	end
    	
    	att0.Parent = Part0
        att1.Parent = Part1
    end
    
    local function respawnrequest()
    	local ccfr = ws.CurrentCamera.CFrame
    	local c = lp.Character
    	lp.Character = nil
    	lp.Character = c
    	local con = nil
    	con = ws.CurrentCamera.Changed:Connect(function(prop)
    	    if (prop ~= "Parent") and (prop ~= "CFrame") then
    	        return
    	    end
    	    ws.CurrentCamera.CFrame = ccfr
    	    con:Disconnect()
        end)
    end
    
    local destroyhum = (method == 4) or (method == 5)
    local breakjoints = (method == 0) or (method == 4)
    local antirespawn = (method == 0) or (method == 2) or (method == 3)
    
    hatcollide = hatcollide and (method == 0)
    
    addtools = addtools and gp(lp, "Backpack", "Backpack")
    
    local fenv = getfenv()
    local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
    local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad
    
    if shp and (simradius == "shp") then
    	spawn(function()
    		while c and heartbeat:Wait() do
    			shp(lp, "SimulationRadius", inf)
    		end
    	end)
    elseif ssr and (simradius == "ssr") then
    	spawn(function()
    		while c and heartbeat:Wait() do
    			ssr(inf)
    		end
    	end)
    end
    
    antiragdoll = antiragdoll and function(v)
    	if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
    		v.Parent = nil
    	end
    end
    
    if antiragdoll then
    	for i, v in pairs(c:GetDescendants()) do
    		antiragdoll(v)
    	end
    	c.DescendantAdded:Connect(antiragdoll)
    end
    
    if antirespawn then
    	respawnrequest()
    end
    
    if method == 0 then
    	wait(loadtime)
    	if not c then
    		return
    	end
    end
    
    if discharscripts then
    	for i, v in pairs(c:GetChildren()) do
    		if v:IsA("LocalScript") then
    			v.Disabled = true
    		end
    	end
    elseif newanimate then
    	local animate = gp(c, "Animate", "LocalScript")
    	if animate and (not animate.Disabled) then
    		animate.Disabled = true
    	else
    		newanimate = false
    	end
    end
    
    if addtools then
    	for i, v in pairs(addtools:GetChildren()) do
    		if v:IsA("Tool") then
    			v.Parent = c
    		end
    	end
    end
    
    pcall(function()
    	settings().Physics.AllowSleep = false
    	settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
    end)
    
    local OLDscripts = {}
    
    for i, v in pairs(c:GetDescendants()) do
    	if v.ClassName == "Script" then
    		table.insert(OLDscripts, v)
    	end
    end
    
    local scriptNames = {}
    
    for i, v in pairs(c:GetDescendants()) do
    	if v:IsA("BasePart") then
    		local newName = tostring(i)
    		local exists = true
    		while exists do
    			exists = false
    			for i, v in pairs(OLDscripts) do
    				if v.Name == newName then
    					exists = true
    				end
    			end
    			if exists then
    				newName = newName .. "_"    
    			end
    		end
    		table.insert(scriptNames, newName)
    		Instance.new("Script", v).Name = newName
    	end
    end
    
    c.Archivable = true
    local hum = c:FindFirstChildOfClass("Humanoid")
    if hum then
    	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
    		v:Stop()
    	end
    end
    local cl = c:Clone()
    if hum and humState16 then
        hum:ChangeState(Enum.HumanoidStateType.Physics)
        if destroyhum then
            wait(1.6)
        end
    end
    if hum and hum.Parent and destroyhum then
        hum:Destroy()
    end
    
    if not c then
        return
    end
    
    local head = gp(c, "Head", "BasePart")
    local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
    local root = gp(c, "HumanoidRootPart", "BasePart")
    if hatcollide and c:FindFirstChildOfClass("Accessory") then
        local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
        if not (torso and root and anything) then
            return
        end
        torso:Destroy()
        root:Destroy()
        if shp then
            for i,v in pairs(c:GetChildren()) do
                if v:IsA("Accessory") then
                    shp(v, "BackendAccoutrementState", 0)
                end 
            end
        end
        anything:Destroy()
    end
    
    local model = Instance.new("Model", c)
    model.Name = model.ClassName
    
    model:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (model and model.Parent) then
    	    model = nil
        end
    end)
    
    for i, v in pairs(c:GetChildren()) do
    	if v ~= model then
    		if addtools and v:IsA("Tool") then
    			for i1, v1 in pairs(v:GetDescendants()) do
    				if v1 and v1.Parent and v1:IsA("BasePart") then
    					local bv = Instance.new("BodyVelocity", v1)
    					bv.Velocity = v3_0
    					bv.MaxForce = v3(1000, 1000, 1000)
    					bv.P = 1250
    					bv.Name = "bv_" .. v.Name
    				end
    			end
    		end
    		v.Parent = model
    	end
    end
    
    if breakjoints then
    	model:BreakJoints()
    else
    	if head and torso then
    		for i, v in pairs(model:GetDescendants()) do
    			if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
    				local save = false
    				if (v.Part0 == torso) and (v.Part1 == head) then
    					save = true
    				end
    				if (v.Part0 == head) and (v.Part1 == torso) then
    					save = true
    				end
    				if save then
    					if hedafterneck then
    						hedafterneck = v
    					end
    				else
    					v:Destroy()
    				end
    			end
    		end
    	end
    	if method == 3 then
    		spawn(function()
    			wait(loadtime)
    			if model then
    				model:BreakJoints()
    			end
    		end)
    	end
    end
    
    cl.Parent = c
    for i, v in pairs(cl:GetChildren()) do
    	v.Parent = c
    end
    cl:Destroy()
    
    local noclipmodel = (noclipAllParts and c) or model
    local noclipcon = nil
    local function uncollide()
    	if noclipmodel then
    		for i, v in pairs(noclipmodel:GetDescendants()) do
    		    if v:IsA("BasePart") then
    			    v.CanCollide = false
    		    end
    		end
    	else
    		noclipcon:Disconnect()
    	end
    end
    noclipcon = stepped:Connect(uncollide)
    uncollide()
    
    for i, scr in pairs(model:GetDescendants()) do
    	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
    		local Part0 = scr.Parent
    		if Part0:IsA("BasePart") then
    			for i1, scr1 in pairs(c:GetDescendants()) do
    				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
    					local Part1 = scr1.Parent
    					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
    						align(Part0, Part1)
    						scr:Destroy()
    						scr1:Destroy()
    						break
    					end
    				end
    			end
    		end
    	end
    end
    
    for i, v in pairs(c:GetDescendants()) do
    	if v and v.Parent and (not v:IsDescendantOf(model)) then
    		if v:IsA("Decal") then
    		    v.Transparency = 1
    		elseif v:IsA("BasePart") then
    			v.Transparency = 1
    			v.Anchored = false
    		elseif v:IsA("ForceField") then
    			v.Visible = false
    		elseif v:IsA("Sound") then
    			v.Playing = false
    		elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
    			v.Enabled = false
    		end
    	end
    end
    
    if newanimate then
    	local animate = gp(c, "Animate", "LocalScript")
    	if animate then
    		animate.Disabled = false
    	end
    end
    
    if addtools then
    	for i, v in pairs(c:GetChildren()) do
    		if v:IsA("Tool") then
    			v.Parent = addtools
    		end
    	end
    end
    
    local hum0 = model:FindFirstChildOfClass("Humanoid")
    if hum0 then
        hum0:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (hum0 and hum0.Parent) then
                hum0 = nil
            end
        end)
    end
    
    local hum1 = c:FindFirstChildOfClass("Humanoid")
    if hum1 then
        hum1:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (hum1 and hum1.Parent) then
                hum1 = nil
            end
        end)
        
    	ws.CurrentCamera.CameraSubject = hum1
    	local camSubCon = nil
    	local function camSubFunc()
    		camSubCon:Disconnect()
    		if c and hum1 then
    			ws.CurrentCamera.CameraSubject = hum1
    		end
    	end
    	camSubCon = renderstepped:Connect(camSubFunc)
    	if hum0 then
    		hum0:GetPropertyChangedSignal("Jump"):Connect(function()
    			if hum1 then
    				hum1.Jump = hum0.Jump
    			end
    		end)
    	else
    		respawnrequest()
    	end
    end
    
    local rb = Instance.new("BindableEvent", c)
    rb.Event:Connect(function()
    	rb:Destroy()
    	sg:SetCore("ResetButtonCallback", true)
    	if destroyhum then
    		c:BreakJoints()
    		return
    	end
    	if hum0 and (hum0.Health > 0) then
    		model:BreakJoints()
    		hum0.Health = 0
    	end
    	if antirespawn then
    	    respawnrequest()
    	end
    end)
    sg:SetCore("ResetButtonCallback", rb)
    
    spawn(function()
    	while c do
    		if hum0 and hum1 then
    			hum1.Jump = hum0.Jump
    		end
    		wait()
    	end
    	sg:SetCore("ResetButtonCallback", true)
    end)
    
    R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
    if R15toR6 then
        local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
    	if part then
    	    local cfr = part.CFrame
    		local R6parts = { 
    			head = {
    				Name = "Head",
    				Size = v3(2, 1, 1),
    				R15 = {
    					Head = 0
    				}
    			},
    			torso = {
    				Name = "Torso",
    				Size = v3(2, 2, 1),
    				R15 = {
    					UpperTorso = 0.2,
    					LowerTorso = -0.8
    				}
    			},
    			root = {
    				Name = "HumanoidRootPart",
    				Size = v3(2, 2, 1),
    				R15 = {
    					HumanoidRootPart = 0
    				}
    			},
    			leftArm = {
    				Name = "Left Arm",
    				Size = v3(1, 2, 1),
    				R15 = {
    					LeftHand = -0.85,
    					LeftLowerArm = -0.2,
    					LeftUpperArm = 0.4
    				}
    			},
    			rightArm = {
    				Name = "Right Arm",
    				Size = v3(1, 2, 1),
    				R15 = {
    					RightHand = -0.85,
    					RightLowerArm = -0.2,
    					RightUpperArm = 0.4
    				}
    			},
    			leftLeg = {
    				Name = "Left Leg",
    				Size = v3(1, 2, 1),
    				R15 = {
    					LeftFoot = -0.85,
    					LeftLowerLeg = -0.15,
    					LeftUpperLeg = 0.6
    				}
    			},
    			rightLeg = {
    				Name = "Right Leg",
    				Size = v3(1, 2, 1),
    				R15 = {
    					RightFoot = -0.85,
    					RightLowerLeg = -0.15,
    					RightUpperLeg = 0.6
    				}
    			}
    		}
    		for i, v in pairs(c:GetChildren()) do
    			if v:IsA("BasePart") then
    				for i1, v1 in pairs(v:GetChildren()) do
    					if v1:IsA("Motor6D") then
    						v1.Part0 = nil
    					end
    				end
    			end
    		end
    		part.Archivable = true
    		for i, v in pairs(R6parts) do
    			local part = part:Clone()
    			part:ClearAllChildren()
    			part.Name = v.Name
    			part.Size = v.Size
    			part.CFrame = cfr
    			part.Anchored = false
    			part.Transparency = 1
    			part.CanCollide = false
    			for i1, v1 in pairs(v.R15) do
    				local R15part = gp(c, i1, "BasePart")
    				local att = gp(R15part, "att1_" .. i1, "Attachment")
    				if R15part then
    					local weld = Instance.new("Weld", R15part)
    					weld.Name = "Weld_" .. i1
    					weld.Part0 = part
    					weld.Part1 = R15part
    					weld.C0 = cf(0, v1, 0)
    					weld.C1 = cf(0, 0, 0)
    					R15part.Massless = true
    					R15part.Name = "R15_" .. i1
    					R15part.Parent = part
    					if att then
    						att.Parent = part
    						att.Position = v3(0, v1, 0)
    					end
    				end
    			end
    			part.Parent = c
    			R6parts[i] = part
    		end
    		local R6joints = {
    			neck = {
    				Parent = R6parts.torso,
    				Name = "Neck",
    				Part0 = R6parts.torso,
    				Part1 = R6parts.head,
    				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
    				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
    			},
    			rootJoint = {
    				Parent = R6parts.root,
    				Name = "RootJoint" ,
    				Part0 = R6parts.root,
    				Part1 = R6parts.torso,
    				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
    				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
    			},
    			rightShoulder = {
    				Parent = R6parts.torso,
    				Name = "Right Shoulder",
    				Part0 = R6parts.torso,
    				Part1 = R6parts.rightArm,
    				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
    				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
    			},
    			leftShoulder = {
    				Parent = R6parts.torso,
    				Name = "Left Shoulder",
    				Part0 = R6parts.torso,
    				Part1 = R6parts.leftArm,
    				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
    				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
    			},
    			rightHip = {
    				Parent = R6parts.torso,
    				Name = "Right Hip",
    				Part0 = R6parts.torso,
    				Part1 = R6parts.rightLeg,
    				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
    				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
    			},
    			leftHip = {
    				Parent = R6parts.torso,
    				Name = "Left Hip" ,
    				Part0 = R6parts.torso,
    				Part1 = R6parts.leftLeg,
    				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
    				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
    			}
    		}
    		for i, v in pairs(R6joints) do
    			local joint = Instance.new("Motor6D")
    			for prop, val in pairs(v) do
    				joint[prop] = val
    			end
    			R6joints[i] = joint
    		end
    		if hum1 then
        		hum1.RigType = Enum.HumanoidRigType.R6
        		hum1.HipHeight = 0
    		end
    	end
    end
    
    local torso1 = torso
    torso = gp(c, "Torso", "BasePart") or ((not R15toR6) and gp(c, torso.Name, "BasePart"))
    if (typeof(hedafterneck) == "Instance") and head and torso and torso1 then
    	local conNeck = nil
    	local conTorso = nil
    	local contorso1 = nil
    	local aligns = {}
    	local function enableAligns()
    	    conNeck:Disconnect()
            conTorso:Disconnect()
            conTorso1:Disconnect()
    		for i, v in pairs(aligns) do
    			v.Enabled = true
    		end
    	end
    	conNeck = hedafterneck.Changed:Connect(function(prop)
    	    if table.find({"Part0", "Part1", "Parent"}, prop) then
    	        enableAligns()
    		end
    	end)
    	conTorso = torso:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
    	conTorso1 = torso1:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
    	for i, v in pairs(head:GetDescendants()) do
    		if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
    			i = tostring(i)
    			aligns[i] = v
    			v:GetPropertyChangedSignal("Parent"):Connect(function()
    			    aligns[i] = nil
    			end)
    			v.Enabled = false
    		end
    	end
    end
    
    --[[
        fling function
        usage: fling(target, duration, velocity)
        target can be set to: basePart, CFrame, Vector3, character model or humanoid
        duration (fling time) can be set to a number or a string containing the number (in seconds) will be set to 0.5 if not provided,
        velocity (fling part rotation velocity) can be set to a vector3 value (Vector3.new(20000, 20000, 20000) if not provided)
    ]]
    
    local flingpart0 = gp(model, flingpart, "BasePart")
    local flingpart1 = gp(c, flingpart, "BasePart")
    
    local fling = function() end
    if flingpart0 and flingpart1 then
        flingpart0:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (flingpart0 and flingpart0.Parent) then
                flingpart0 = nil
                fling = function() end
            end
        end)
        flingpart0.Archivable = true
        flingpart1:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (flingpart1 and flingpart1.Parent) then
                flingpart1 = nil
                fling = function() end
            end
        end)
        local att0 = gp(flingpart0, "att0_" .. flingpart0.Name, "Attachment")
        local att1 = gp(flingpart1, "att1_" .. flingpart1.Name, "Attachment")
        if att0 and att1 then
            att0:GetPropertyChangedSignal("Parent"):Connect(function()
                if not (att0 and att0.Parent) then
                    att0 = nil
                    fling = function() end
                end
            end)
            att1:GetPropertyChangedSignal("Parent"):Connect(function()
                if not (att1 and att1.Parent) then
                    att1 = nil
                    fling = function() end
                end
            end)
            local lastfling = nil
            fling = function(target, duration, rotVelocity)
                if typeof(target) == "Instance" then
                    if target:IsA("BasePart") then
                        target = target.Position
                    elseif target:IsA("Model") then
                        target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                        if target then
                            target = target.Position
                        else
                            return
                        end
                    elseif target:IsA("Humanoid") then
                        local parent = target.Parent
                        if not (parent and parent:IsA("Model")) then
                            return
                        end
                        target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                        if target then
                            target = target.Position
                        else
                            return
                        end
                    else
                        return
                    end
                elseif typeof(target) == "CFrame" then
                    target = target.Position
                elseif typeof(target) ~= "Vector3" then
                    return
                end
                lastfling = target
                if type(duration) ~= "number" then
                    duration = tonumber(duration) or 0.5
                end
                if typeof(rotVelocity) ~= "Vector3" then
                    rotVelocity = v3(20000, 20000, 20000)
                end
                if not (target and flingpart0 and flingpart1 and att0 and att1) then
                    return
                end
                local flingpart = flingpart0:Clone()
                flingpart.Transparency = 1
                flingpart.Size = v3(0.01, 0.01, 0.01)
                flingpart.CanCollide = false
                flingpart.Name = "flingpart_" .. flingpart0.Name
                flingpart.Anchored = true
                flingpart.Velocity = v3_0
                flingpart.RotVelocity = v3_0
                flingpart:GetPropertyChangedSignal("Parent"):Connect(function()
                    if not (flingpart and flingpart.Parent) then
                        flingpart = nil
                    end
                end)
                flingpart.Parent = flingpart1
                if flingpart0.Transparency > 0.5 then
                    flingpart0.Transparency = 0.5
                end
                att1.Parent = flingpart
                for i, v in pairs(att0:GetChildren()) do
                    if v:IsA("AlignOrientation") then
                        v.Enabled = false
                    end
                end
                local con = nil
                con = heartbeat:Connect(function()
                    if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                        flingpart0.RotVelocity = rotVelocity
                        flingpart.Position = target
                    else
                        con:Disconnect()
                    end
                end)
                local rsteppedRotVel = v3(
                    ((rotVelocity.X > 0) and -1) or 1,
                    ((rotVelocity.Y > 0) and -1) or 1,
                    ((rotVelocity.Z > 0) and -1) or 1
                )
                local con = nil
                con = renderstepped:Connect(function()
                    if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                        flingpart0.RotVelocity = rsteppedRotVel
                        flingpart.Position = target
                    else
                        con:Disconnect()
                    end
                end)
                wait(duration)
                if lastfling ~= target then
                    if flingpart then
                        if att1 and (att1.Parent == flingpart) then
                            att1.Parent = flingpart1
                        end
                        flingpart:Destroy()
                    end
                    return
                end
                target = nil
                if not (flingpart and flingpart0 and flingpart1 and att0 and att1) then
                    return
                end
                flingpart0.RotVelocity = v3_0
                att1.Parent = flingpart1
                for i, v in pairs(att0:GetChildren()) do
                    if v:IsA("AlignOrientation") then
                        v.Enabled = true
                    end
                end
                if flingpart then
                    flingpart:Destroy()
                end
            end
        end
    end
end

local lp = game:GetService("Players").LocalPlayer

local c = lp.Character
if not (c and c.Parent) then
	return print("character not found")
end
c:GetPropertyChangedSignal("Parent"):Connect(function()
    if not (c and c.Parent) then
        c = nil
    end
end)

--getPart function

local function gp(parent, name, className)
	local ret = nil
	pcall(function()
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
				break
			end
		end
	end)
	return ret
end

--check if reanimate loaded

local model = gp(c, "Model", "Model")
if not model then return print("model not found") end

--find body parts

local head = gp(c, "Head", "BasePart")
if not head then return print("head not found") end

local torso = gp(c, "Torso", "BasePart")
if not torso then return print("torso not found") end

local humanoidRootPart = gp(c, "HumanoidRootPart", "BasePart")
if not humanoidRootPart then return print("humanoid root part not found") end

local leftArm = gp(c, "Left Arm", "BasePart")
if not leftArm then return print("left arm not found") end

local rightArm = gp(c, "Right Arm", "BasePart")
if not rightArm then return print("right arm not found") end

local leftLeg = gp(c, "Left Leg", "BasePart")
if not leftLeg then return print("left leg not found") end

local rightLeg = gp(c, "Right Leg", "BasePart")
if not rightLeg then return print("right leg not found") end

--find rig joints

local neck = gp(torso, "Neck", "Motor6D")
if not neck then return print("neck not found") end

local rootJoint = gp(humanoidRootPart, "RootJoint", "Motor6D")
if not rootJoint then return print("root joint not found") end

local leftShoulder = gp(torso, "Left Shoulder", "Motor6D")
if not leftShoulder then return print("left shoulder not found") end

local rightShoulder = gp(torso, "Right Shoulder", "Motor6D")
if not rightShoulder then return print("right shoulder not found") end

local leftHip = gp(torso, "Left Hip", "Motor6D")
if not leftHip then return print("left hip not found") end

local rightHip = gp(torso, "Right Hip", "Motor6D")
if not rightHip then return print("right hip not found") end

--humanoid

local hum = c:FindFirstChildOfClass("Humanoid")
if not hum then return print("humanoid not found") end

local animate = gp(c, "Animate", "LocalScript")
if animate then
	animate.Disabled = true
end

for i, v in pairs(hum:GetPlayingAnimationTracks()) do
	v:Stop()
end

local fps = 60
local sinechange = 40 / fps
local event = Instance.new("BindableEvent", c)
event.Name = "renderstepped"
local floor = math.floor
fps = 1 / fps
local tf = 0
local con = nil
con = game:GetService("RunService").RenderStepped:Connect(function(s)
	if not c then
		con:Disconnect()
		return
	end
	tf += s
	if tf >= fps then
		for i=1, floor(tf / fps) do
		    tf -= fps
			event:Fire(c)
		end
	end
end)
local event = event.Event

local function stopIfRemoved(instance)
    if not (instance and instance.Parent) then
        c = nil
        return
    end
    instance:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (instance and instance.Parent) then
            c = nil
        end
    end)
end
stopIfRemoved(c)
stopIfRemoved(hum)
for i, v in pairs({head, torso, leftArm, rightArm, leftLeg, rightLeg, humanoidRootPart}) do
    stopIfRemoved(v)
end
for i, v in pairs({neck, rootJoint, leftShoulder, rightShoulder, leftHip, rightHip}) do
    stopIfRemoved(v)
end
if not c then
    return
end
local mode = false
uis = game:GetService("UserInputService")
local modes = {
}
uis.InputBegan:Connect(function(keycode)
    if uis:GetFocusedTextBox() then
        return
    end
	keycode = keycode.KeyCode
	if modes[keycode] ~= nil then
		if mode == modes[keycode] then
			mode = nil
		else
			mode = modes[keycode]
		end
	end
end)

local cf, v3, euler, sin, sine = CFrame.new, Vector3.new, CFrame.fromEulerAnglesXYZ, math.sin, 0
while event:Wait() do
    sine += sinechange
    local vel = humanoidRootPart.Velocity
    if (vel*v3(1, 0, 1)).Magnitude > 2 then -- walk
        neck.C0 = neck.C0:Lerp(cf(0, 1, 0) * euler(-1.6580627893946132 + -0.17453292519943295 * sin(sine * 0.4), -0.04363323129985824 * sin(sine * 0.2), -3.1590459461097367 + -0.08726646259971647 * sin((sine + -2.5) * 0.2)), 0.2) 
        rootJoint.C0 = rootJoint.C0:Lerp(cf(0, 0.2 + 0.2 * sin(sine * 0.4), 0) * euler(-1.6580627893946132 + 0.08726646259971647 * sin((sine + -1) * 0.4), 0.08726646259971647 * sin(sine * 0.2), -3.1590459461097367 + 0.17453292519943295 * sin((sine + -2.5) * 0.2)), 0.2) 
        leftShoulder.C0 = leftShoulder.C0:Lerp(cf(-1, 0.5, 0) * euler(1.5707963267948966, -1.8962634015954636, 1.2217304763960306 + -0.6981317007977318 * sin((sine + -2.5) * 0.2)), 0.2) 
        rightShoulder.C0 = rightShoulder.C0:Lerp(cf(1, 0.5, 0) * euler(1.5707963267948966, 1.8962634015954636, -1.2217304763960306 + -0.6981317007977318 * sin((sine + -2.5) * 0.2)), 0.2) 
        leftHip.C0 = leftHip.C0:Lerp(cf(-1, -1 + -0.3 * sin((sine + 5) * 0.2), 0) * euler(1.5707963267948966 + -0.8726646259971648 * sin(sine * 0.2), -1.5707963267948966 + 0.08726646259971647 * sin(sine * 0.2), 1.5707963267948966), 0.2) 
        rightHip.C0 = rightHip.C0:Lerp(cf(1, -1 + 0.3 * sin((sine + 5) * 0.2), 0) * euler(1.5707963267948966 + 0.8726646259971648 * sin(sine * 0.2), 1.5707963267948966 + 0.08726646259971647 * sin(sine * 0.2), -1.5707963267948966), 0.2) 
    elseif vel.Y > 2 then -- jump
        neck.C0 = neck.C0:Lerp(cf(0 + 0 * sin((sine + 0) * 0.1), 1 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1)) * euler(-1.3962634015954636 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1), -3.1590459461097367 + 0 * sin((sine + 0) * 0.1)), 0.2) 
        rootJoint.C0 = rootJoint.C0:Lerp(cf(0 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1)) * euler(-1.3962634015954636 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1), -3.141592653589793 + 0 * sin((sine + 0) * 0.1)), 0.2) 
        leftShoulder.C0 = leftShoulder.C0:Lerp(cf(-1 + 0 * sin((sine + 0) * 0.1), 0.5 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1)) * euler(-0 + 0 * sin((sine + 0) * 0.1), -0.7853981633974483 + 0 * sin((sine + 0) * 0.1), -2.443460952792061 + 0 * sin((sine + 0) * 0.1)), 0.2) 
        rightShoulder.C0 = rightShoulder.C0:Lerp(cf(1 + 0 * sin((sine + 0) * 0.1), 0.5 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1)) * euler(0 + 0 * sin((sine + 0) * 0.1), 0.7853981633974483 + 0 * sin((sine + 0) * 0.1), 2.443460952792061 + 0 * sin((sine + 0) * 0.1)), 0.2) 
        leftHip.C0 = leftHip.C0:Lerp(cf(-1 + 0 * sin((sine + 0) * 0.1), -1 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1)) * euler(-0.6981317007977318 + 0 * sin((sine + 0) * 0.1), -1.5882496193148399 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1)), 0.2) 
        rightHip.C0 = rightHip.C0:Lerp(cf(1 + 0 * sin((sine + 0) * 0.1), -1 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1)) * euler(0 + 0 * sin((sine + 0) * 0.1), 1.5707963267948966 + 0 * sin((sine + 0) * 0.1), -0.6981317007977318 + 0 * sin((sine + 0) * 0.1)), 0.2)
    elseif vel.Y < -2 then -- fall
        neck.C0 = neck.C0:Lerp(cf(0 + 0 * sin((sine + 0) * 0.1), 1 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1)) * euler(-1.7453292519943295 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1), -3.141592653589793 + 0 * sin((sine + 0) * 0.1)), 0.2) 
        rootJoint.C0 = rootJoint.C0:Lerp(cf(0 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1)) * euler(-1.7453292519943295 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1), -3.141592653589793 + 0 * sin((sine + 0) * 0.1)), 0.2) 
        leftShoulder.C0 = leftShoulder.C0:Lerp(cf(-1 + 0 * sin((sine + 0) * 0.1), 0.5 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1)) * euler(-0 + 0 * sin((sine + 0) * 0.1), -1.2217304763960306 + 0 * sin((sine + 0) * 0.1), -0.8726646259971648 + 0 * sin((sine + 0) * 0.1)), 0.2) 
        rightShoulder.C0 = rightShoulder.C0:Lerp(cf(1 + 0 * sin((sine + 0) * 0.1), 0.5 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1)) * euler(0 + 0 * sin((sine + 0) * 0.1), 1.2217304763960306 + 0 * sin((sine + 0) * 0.1), 0.8726646259971648 + 0 * sin((sine + 0) * 0.1)), 0.2) 
        leftHip.C0 = leftHip.C0:Lerp(cf(-1 + 0 * sin((sine + 0) * 0.1), -1 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1)) * euler(0.5235987755982988 + 0 * sin((sine + 0) * 0.1), -1.5707963267948966 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1)), 0.2) 
        rightHip.C0 = rightHip.C0:Lerp(cf(1 + 0 * sin((sine + 0) * 0.1), -1 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1)) * euler(0.5235987755982988 + 0 * sin((sine + 0) * 0.1), 1.5707963267948966 + 0 * sin((sine + 0) * 0.1), 0 + 0 * sin((sine + 0) * 0.1)), 0.2)
    else -- idle
		if not mode then
            neck.C0 = neck.C0:Lerp(cf(0, 1, 0) * euler(-1.2882496193148399 + 0.08726646259971647 * sin((sine + -30) * 0.05), 0, -3.1590459461097367), 0.2)
            rootJoint.C0 = rootJoint.C0:Lerp(cf(0, 0.06 * sin(sine * 0.10), 1) * euler(-1.2882496193148399 + 0.05235987755982989 * sin(sine * 0.01), 0, -3.1590459461097367), 0.2) 
            leftShoulder.C0 = leftShoulder.C0:Lerp(cf(-1.05, 0.50 + 0.1 * sin((sine + -15) * 0.05), -0.05 + 0.08 * sin(sine * 0.05)) * euler(0.7707963267948966 + 0.28726646259971647 * sin(sine * 0.05), -1.7853981633974483, 1.2453292519943295), 0.2) 
            rightShoulder.C0 = rightShoulder.C0:Lerp(cf(1.05, 0.50 + 0.1 * sin((sine + -15) * 0.05), -0.05 + 0.08 * sin(sine * 0.05)) * euler(0.7707963267948966 + 0.28726646259971647 * sin(sine * 0.05), 1.7853981633974483, -1.2453292519943295), 0.2) 
            leftHip.C0 = leftHip.C0:Lerp(cf(-1, -1 + -0.1 * sin(sine * 0.01), 0.05 * sin(sine * 0.05)) * euler(1.2707963267948966, -1.6580627893946132, 1.5707963267948966 + 0.05235987755982989 * sin(sine * 0.05)), 0.2) 
            rightHip.C0 = rightHip.C0:Lerp(cf(1, -1 + -0.1 * sin(sine * 0.01), 0.05 * sin(sine * 0.05)) * euler(1.2707963267948966, 1.6580627893946132, -1.5707963267948966 + -0.05235987755982989 * sin(sine * 0.05)), 0.2) 
--[[MW_animator progress save: 0, 0, 0, 0.1, -91, 15, -30, 0.025, 1, 0, 0, 0.1, 0, 10, -10, 0.05, 0, 0, 0, 0.1, -181, 10, 30, 0.05, 0, 1, 30, 0.05, -91, 10, -15, 0.025, 5, 1, 0, 0.05, 0, 10, 0, 0.05, 0, 1, 0, 0.025, -181, 20, 15, 0.05, -1, 0, 0, 0.1, 90, -20, -30, 0.025, 0.5, 0, 0, 0.1, -91, 20, -10, 0.05, 0, 0, 0, 0.1, 90, 0, 30, 0, 1, 0, 0, 0.1, 90, -20, -30, 0.025, 0.5, 0, 0, 0.1, 90, 20, -20, 0.05, 0, 0, 0, 0.1, -90, 0, 0, 0.1, -1, 0, 0, 0.1, 90, 0, 0, 0.1, -1, 0, 0, 0.1, -91, 15, -7, 0.05, 0, 0, 0, 0.1, 90, 20, -10, 0.025, 1, 0, 0, 0.1, 90, 0, 0, 0.1, -1, 0, 0, 0.1, 90, 15, -10, 0.05, 0, 0, 0, 0.1, -90, -20, -5, 0.025]]
        end
    end
end
end)


local FirstLabel = FirstPage.AddLabel("Script")

local FirstButton = FirstPage.AddButton("(Fe) PP", function()
game:GetService("StarterGui"):SetCore("SendNotification", { 
	Title = "Control ( F ) ";
	Text = "";
    Icon = ""})--rbxthumb://type=Asset&id=5107182114&w=150&h=150

local args = {
    [1] = ";morph me DonaldTrump "
}
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))

local Player = game.Players.LocalPlayer
local Time = 5
local lastpostion = Player.Character.HumanoidRootPart.CFrame
Player.Character.HumanoidRootPart.CFrame = CFrame.new(220.559616, 467.11972, 15.9669914, 0.948876262, 0.00119010347, -0.315646082, -8.76804673e-09, 0.999992907, 0.00377031998, 0.315648317, -0.00357756414, 0.948869526)

wait(.4)
local args = {
    [1] = ";Freeze "
}
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
local args = {
    [1] = ";morph me Noob1 "
}
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
local args = {
    [1] = ";char "
}
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
wait(2)
local args = {
    [1] = ";char me 4152000667 " -- 3265501564
}
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
wait(2)
local args = {
    [1] = ";shirt me 9537661006 "
}
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))

wait(0.5)
local c = game:GetService("Players").LocalPlayer.character
if not (c and c.Parent) then
    return
end

local Vector3_101 = Vector3.new(1, 0, 1)
local netless_Y = Vector3.new(0, 25.1, 0)
local function getNetlessVelocity(realPartVelocity) --edit this if you have a better netless method
    local netlessVelocity = realPartVelocity * Vector3_101
    local mag = netlessVelocity.Magnitude
    if mag > 10 then
        netlessVelocity *= 100 / mag
    end
    netlessVelocity += netless_Y
    return netlessVelocity
end
local simradius = "shp" --simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = false --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = false --tries to convert your character to r6 if its r15
local hatcollide = false --makes hats cancollide (only method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = false --disable aligns for head and enable after neck is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 2 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 3 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = v3(0, 0, 0)
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
 return
end

c.Destroying:Connect(function()
 c = nil
end)

local function gp(parent, name, className)
 if typeof(parent) == "Instance" then
  for i, v in pairs(parent:GetChildren()) do
   if (v.Name == name) and v:IsA(className) then
    return v
   end
  end
 end
 return nil
end

local function align(Part0, Part1)
 Part0.CustomPhysicalProperties = PhysicalProperties.new(0.0001, 0.0001, 0.0001, 0.0001, 0.0001)

 local att0 = Instance.new("Attachment", Part0)
 att0.Orientation = v3_0
 att0.Position = v3_0
 att0.Name = "att0_" .. Part0.Name
 local att1 = Instance.new("Attachment", Part1)
 att1.Orientation = v3_0
 att1.Position = v3_0
 att1.Name = "att1_" .. Part1.Name

 if (alignmode == 1) or (alignmode == 2) then
  local ape = Instance.new("AlignPosition", att0)
  ape.ApplyAtCenterOfMass = false
  ape.MaxForce = inf
  ape.MaxVelocity = inf
  ape.ReactionForceEnabled = false
  ape.Responsiveness = 200
  ape.Attachment1 = att1
  ape.Attachment0 = att0
  ape.Name = "AlignPositionRtrue"
  ape.RigidityEnabled = true
 end

 if (alignmode == 2) or (alignmode == 3) then
  local apd = Instance.new("AlignPosition", att0)
  apd.ApplyAtCenterOfMass = false
  apd.MaxForce = inf
  apd.MaxVelocity = inf
  apd.ReactionForceEnabled = false
  apd.Responsiveness = 200
  apd.Attachment1 = att1
  apd.Attachment0 = att0
  apd.Name = "AlignPositionRfalse"
  apd.RigidityEnabled = false
 end

 local ao = Instance.new("AlignOrientation", att0)
 ao.MaxAngularVelocity = inf
 ao.MaxTorque = inf
 ao.PrimaryAxisOnly = false
 ao.ReactionTorqueEnabled = false
 ao.Responsiveness = 200
 ao.Attachment1 = att1
 ao.Attachment0 = att0
 ao.RigidityEnabled = false

 if type(getNetlessVelocity) == "function" then
     local realVelocity = v3_0
        local steppedcon = stepped:Connect(function()
            Part0.Velocity = realVelocity
        end)
        local heartbeatcon = heartbeat:Connect(function()
            realVelocity = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(realVelocity)
        end)
        Part0.Destroying:Connect(function()
            Part0 = nil
            steppedcon:Disconnect()
            heartbeatcon:Disconnect()
        end)
    end
end

local function respawnrequest()
 local ccfr = ws.CurrentCamera.CFrame
 local c = lp.Character
 lp.Character = nil
 lp.Character = c
 local con = nil
 con = ws.CurrentCamera.Changed:Connect(function(prop)
     if (prop ~= "Parent") and (prop ~= "CFrame") then
         return
     end
     ws.CurrentCamera.CFrame = ccfr
     con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad

if shp and (simradius == "shp") then
 spawn(function()
  while c and heartbeat:Wait() do
   shp(lp, "SimulationRadius", inf)
  end
 end)
elseif ssr and (simradius == "ssr") then
 spawn(function()
  while c and heartbeat:Wait() do
   ssr(inf)
  end
 end)
end

antiragdoll = antiragdoll and function(v)
 if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
  v.Parent = nil
 end
end

if antiragdoll then
 for i, v in pairs(c:GetDescendants()) do
  antiragdoll(v)
 end
 c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
 respawnrequest()
end

if method == 0 then
 wait(loadtime)
 if not c then
  return
 end
end

if discharscripts then
 for i, v in pairs(c:GetChildren()) do
  if v:IsA("LocalScript") then
   v.Disabled = true
  end
 end
elseif newanimate then
 local animate = gp(c, "Animate", "LocalScript")
 if animate and (not animate.Disabled) then
  animate.Disabled = true
 else
  newanimate = false
 end
end

if addtools then
 for i, v in pairs(addtools:GetChildren()) do
  if v:IsA("Tool") then
   v.Parent = c
  end
 end
end

pcall(function()
 settings().Physics.AllowSleep = false
 settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
 if v.ClassName == "Script" then
  table.insert(OLDscripts, v)
 end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
 if v:IsA("BasePart") then
  local newName = tostring(i)
  local exists = true
  while exists do
   exists = false
   for i, v in pairs(OLDscripts) do
    if v.Name == newName then
     exists = true
    end
   end
   if exists then
    newName = newName .. "_"    
   end
  end
  table.insert(scriptNames, newName)
  Instance.new("Script", v).Name = newName
 end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
 for i, v in pairs(hum:GetPlayingAnimationTracks()) do
  v:Stop()
 end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Accessory") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    torso:Destroy()
    root:Destroy()
    if shp then
        for i,v in pairs(c:GetChildren()) do
            if v:IsA("Accessory") then
                shp(v, "BackendAccoutrementState", 0)
            end 
        end
    end
    anything:Destroy()
end

for i, v in pairs(cl:GetDescendants()) do
 if v:IsA("BasePart") then
  v.Transparency = 1
  v.Anchored = false
 end
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model.Destroying:Connect(function()
 model = nil
end)

for i, v in pairs(c:GetChildren()) do
 if v ~= model then
  if addtools and v:IsA("Tool") then
   for i1, v1 in pairs(v:GetDescendants()) do
    if v1 and v1.Parent and v1:IsA("BasePart") then
     local bv = Instance.new("BodyVelocity", v1)
     bv.Velocity = v3_0
     bv.MaxForce = v3(1000, 1000, 1000)
     bv.P = 1250
     bv.Name = "bv_" .. v.Name
    end
   end
  end
  v.Parent = model
 end
end

if breakjoints then
 model:BreakJoints()
else
 if head and torso then
  for i, v in pairs(model:GetDescendants()) do
   if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
    local save = false
    if (v.Part0 == torso) and (v.Part1 == head) then
     save = true
    end
    if (v.Part0 == head) and (v.Part1 == torso) then
     save = true
    end
    if save then
     if hedafterneck then
      hedafterneck = v
     end
    else
     v:Destroy()
    end
   end
  end
 end
 if method == 3 then
  spawn(function()
   wait(loadtime)
   if model then
    model:BreakJoints()
   end
  end)
 end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
 v.Parent = c
end
cl:Destroy()

local modelDes = {}
for i, v in pairs(model:GetDescendants()) do
 if v:IsA("BasePart") then
  i = tostring(i)
  v.Destroying:Connect(function()
   modelDes[i] = nil
  end)
  modelDes[i] = v
 end
end
local modelcolcon = nil
local function modelcolf()
 if model then
  for i, v in pairs(modelDes) do
   v.CanCollide = false
  end
 else
  modelcolcon:Disconnect()
 end
end
modelcolcon = stepped:Connect(modelcolf)
modelcolf()

for i, scr in pairs(model:GetDescendants()) do
 if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
  local Part0 = scr.Parent
  if Part0:IsA("BasePart") then
   for i1, scr1 in pairs(c:GetDescendants()) do
    if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
     local Part1 = scr1.Parent
     if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
      align(Part0, Part1)
      break
     end
    end
   end
  end
 end
end

if (typeof(hedafterneck) == "Instance") and head then
 local aligns = {}
 local con = nil
 con = hedafterneck.Changed:Connect(function(prop)
     if (prop == "Parent") and not hedafterneck.Parent then
         con:Disconnect()
      for i, v in pairs(aligns) do
       v.Enabled = true
      end
  end
 end)
 for i, v in pairs(head:GetDescendants()) do
  if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
   i = tostring(i)
   aligns[i] = v
   v.Destroying:Connect(function()
       aligns[i] = nil
   end)
   v.Enabled = false
  end
 end
end

for i, v in pairs(c:GetDescendants()) do
 if v and v.Parent then
  if v.ClassName == "Script" then
   if table.find(scriptNames, v.Name) then
    v:Destroy()
   end
  elseif not v:IsDescendantOf(model) then
   if v:IsA("Decal") then
    v.Transparency = 1
   elseif v:IsA("ForceField") then
    v.Visible = false
   elseif v:IsA("Sound") then
    v.Playing = false
   elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
    v.Enabled = false
   end
  end
 end
end

if newanimate then
 local animate = gp(c, "Animate", "LocalScript")
 if animate then
  animate.Disabled = false
 end
end

if addtools then
 for i, v in pairs(c:GetChildren()) do
  if v:IsA("Tool") then
   v.Parent = addtools
  end
 end
end




wait(1)
local args = {
    [1] = ";hat me 20011897 "
}
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
wait(1)
local args = {
    [1] = ";hat me 12548563 "
}
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))


wait(0.3)
local function align(part0, part1, pos0, rot1)
    part0.Handle.AccessoryWeld:Destroy()
    local attachment0 = Instance.new("Attachment", part0.Handle)
        attachment0.Position = pos0
        attachment0.Orientation = rot1
    local attachment1 = Instance.new("Attachment", part1)
    local AliPos = Instance.new("AlignPosition", part0.Handle)
        AliPos.Attachment0 = attachment0
        AliPos.Attachment1 = attachment1
        AliPos.RigidityEnabled = false
        AliPos.ReactionForceEnabled = false
        AliPos.ApplyAtCenterOfMass = false
        AliPos.MaxForce = 5772000
        AliPos.MaxVelocity = math.huge
        AliPos.Responsiveness = 200
    local AliOri = Instance.new("AlignOrientation", part0.Handle)
        AliOri.Attachment0 = attachment0
        AliOri.Attachment1 = attachment1
        AliOri.ReactionTorqueEnabled = false
        AliOri.PrimaryAxisOnly = false
        AliOri.MaxTorque = 5772000
        AliOri.MaxAngularVelocity = math.huge
        AliOri.Responsiveness = 200
end
align(game.Players.LocalPlayer.Character['Space Cop'], game.Players.LocalPlayer.Character['Torso'], Vector3.new(0.6,3.6,0), Vector3.new(0,0,0))
align(game.Players.LocalPlayer.Character['SpaceHelmetB'], game.Players.LocalPlayer.Character['Torso'], Vector3.new(-0.6,3.6,0), Vector3.new(0,0,0))

local HatChar = game.Players.LocalPlayer.Character
local Hat1 = HatChar:FindFirstChild("Space Cop")
local Hat2 = HatChar:FindFirstChild("SpaceHelmetB")

wait(0.3)
--bypass
loadstring(game:HttpGet("https://pastebin.com/raw/jR00xfMW"))()
 
Hat1.Handle.Mesh:Destroy()
Hat2.Handle.Mesh:Destroy()

local args = {
    [1] = ";unFreeze "
}
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))


local hum0 = model:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0.Destroying:Connect(function()
        hum0 = nil
    end)
end

local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    hum1.Destroying:Connect(function()
        hum1 = nil
    end)
end

if hum1 then
 ws.CurrentCamera.CameraSubject = hum1
 local camSubCon = nil
 local function camSubFunc()
  camSubCon:Disconnect()
  if c and hum1 then
   ws.CurrentCamera.CameraSubject = hum1
  end
 end
 camSubCon = renderstepped:Connect(camSubFunc)
 if hum0 then
  hum0.Changed:Connect(function(prop)
   if hum1 and (prop == "Jump") then
    hum1.Jump = hum0.Jump
   end
  end)
 else
  respawnrequest()
 end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
 rb:Destroy()
 sg:SetCore("ResetButtonCallback", true)
 if destroyhum then
  c:BreakJoints()
  return
 end
 if hum0 and (hum0.Health > 0) then
  model:BreakJoints()
  hum0.Health = 0
 end
 if antirespawn then
     respawnrequest()
 end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
 while c do
  if hum0 and hum1 then
   hum1.Jump = hum0.Jump
  end
  wait()
 end
 sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    --disabled for this script
end

for i, v in pairs({"Torso", "Head", "HumanoidRootPart"}) do
    local part = gp(c, v, "BasePart")
    local att = gp(part, "att1_" .. v, "Attachment")
    if att then
        part.Archivable = true
        local part1 = part:Clone()
        part1.Anchored = true
        part1.CanCollide = false
        part1.Name = "partholder_" .. v
        part1:ClearAllChildren()
        part1.Parent = c
        att.Parent = part1
    end
end

if hum1 then 
    hum1.HipHeight = 5
    hum1.WalkSpeed = 22
    hum1.JumpPower = 50
end

local head = gp(c, "Head", "BasePart")
if not head then return print("head not found") end

local torso = gp(c, "Torso", "BasePart")
if not torso then return print("torso not found") end

local humanoidRootPart = gp(c, "HumanoidRootPart", "BasePart")
if not humanoidRootPart then return print("humanoid root part not found") end

local leftArm = gp(c, "Left Arm", "BasePart")
if not leftArm then return print("left arm not found") end

local rightArm = gp(c, "Right Arm", "BasePart")
if not rightArm then return print("right arm not found") end

local leftLeg = gp(c, "Left Leg", "BasePart")
if not leftLeg then return print("left leg not found") end

local rightLeg = gp(c, "Right Leg", "BasePart")
if not rightLeg then return print("right leg not found") end

--find rig joints

local neck = gp(torso, "Neck", "Motor6D")
if not neck then return print("neck not found") end

local rootJoint = gp(humanoidRootPart, "RootJoint", "Motor6D")
if not rootJoint then return print("root joint not found") end

local leftShoulder = gp(torso, "Left Shoulder", "Motor6D")
if not leftShoulder then return print("left shoulder not found") end

local rightShoulder = gp(torso, "Right Shoulder", "Motor6D")
if not rightShoulder then return print("right shoulder not found") end

local leftHip = gp(torso, "Left Hip", "Motor6D")
if not leftHip then return print("left hip not found") end

local rightHip = gp(torso, "Right Hip", "Motor6D")
if not rightHip then return print("right hip not found") end

--60 fps

local fps = 60
local event = Instance.new("BindableEvent", c)
event.Name = "60 fps"
local floor = math.floor
fps = 1 / fps
local tf = 0
local con = nil
con = game:GetService("RunService").RenderStepped:Connect(function(s)
 if not c then
  con:Disconnect()
  return
 end
 tf += s
 if tf >= fps then
  for i=1, floor(tf / fps) do
   event:Fire(c)
  end
  tf = 0
 end
end)
local event = event.Event

local function stopIfRemoved(instance)
    if not (instance and instance.Parent) then
        c = nil
        return
    end
    instance:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (instance and instance.Parent) then
            c = nil
        end
    end)
end
stopIfRemoved(c)
stopIfRemoved(hum)
for i, v in pairs({head, torso, leftArm, rightArm, leftLeg, rightLeg, humanoidRootPart}) do
    stopIfRemoved(v)
end
for i, v in pairs({neck, rootJoint, leftShoulder, rightShoulder, leftHip, rightHip}) do
    stopIfRemoved(v)
end
if not c then
    return
end
local mode = false
uis = game:GetService("UserInputService")
local modes = {
 [Enum.KeyCode.F] = "emote"
}
uis.InputBegan:Connect(function(keycode)
    if uis:GetFocusedTextBox() then
        return
    end
 keycode = keycode.KeyCode
 if modes[keycode] ~= nil then
  if mode == modes[keycode] then
   mode = nil
  else
   mode = modes[keycode]
  end
 end
end)

Player.Character.HumanoidRootPart.CFrame = lastpostion

leftShoulder.Part0 = leftLeg
rightShoulder.Part0 = rightLeg
local cf, v3, euler, sin, sine, abs = CFrame.new, Vector3.new, CFrame.fromEulerAnglesXYZ, math.sin, 0, math.abs
while event:Wait() do
    sine += 1
    local vel = humanoidRootPart.Velocity
    if abs(vel.Y) > 2 then -- jump
            neck.C0 = neck.C0:Lerp(cf(0, 0, 0) * euler(-1.5882496193148399, 0, -3.1590459461097367), 0.2) 
            rootJoint.C0 = rootJoint.C0:Lerp(cf(0, -3, 0) * euler(-1.5707963267948966, 0, -3.141592653589793), 0.2) 
            leftShoulder.C0 = leftShoulder.C0:Lerp(cf(0.5, 2.2, 0) * euler(0, -1.5707963267948966, 0), 0.2) 
            rightShoulder.C0 = rightShoulder.C0:Lerp(cf(-0.5, 5.5, 0.02) * euler(0, 1.5707963267948966, 0), 0.2) 
            leftHip.C0 = leftHip.C0:Lerp(cf(-0.5, -3.5, -3.5) * euler(-1.58, -1.5707963267948966, 0), 1.2) 
            rightHip.C0 = rightHip.C0:Lerp(cf(0.5, -3.5, -2) * euler(-1.58, 1.5707963267948966, 0), 0.2) 
    elseif (vel*v3(1, 0, 1)).Magnitude > 2 then -- walk
            neck.C0 = neck.C0:Lerp(cf(0, 0, 0) * euler(-1.5882496193148399, 0, -3.1590459461097367), 0.2) 
            rootJoint.C0 = rootJoint.C0:Lerp(cf(0, -3, 0) * euler(-1.5707963267948966, 0, -3.141592653589793), 0.2) 
            leftShoulder.C0 = leftShoulder.C0:Lerp(cf(0.5, 2.2, 0) * euler(0, -1.5707963267948966, 0), 0.2) 
            rightShoulder.C0 = rightShoulder.C0:Lerp(cf(-0.5, 5.5, 0.02) * euler(0, 1.5707963267948966, 0), 0.2) 
            leftHip.C0 = leftHip.C0:Lerp(cf(-0.5, -3.5, -3.5) * euler(-1.58, -1.5707963267948966, 0), 1.2) 
            rightHip.C0 = rightHip.C0:Lerp(cf(0.5, -3.5, -2) * euler(-1.58, 1.5707963267948966, 0), 0.2) 
    else -- idle
  if not mode then
            neck.C0 = neck.C0:Lerp(cf(0, 0, 0) * euler(-1.5882496193148399, 0, -3.1590459461097367), 0.2) 
            rootJoint.C0 = rootJoint.C0:Lerp(cf(0, -3, 0) * euler(-1.5707963267948966, 0, -3.141592653589793), 0.2) 
            leftShoulder.C0 = leftShoulder.C0:Lerp(cf(0.5, 2.2, 0) * euler(0, -1.5707963267948966, 0), 0.2) 
            rightShoulder.C0 = rightShoulder.C0:Lerp(cf(-0.5, 5.5, 0.02) * euler(0, 1.5707963267948966, 0), 0.2) 
            leftHip.C0 = leftHip.C0:Lerp(cf(-0.5, -3.5, -3.5) * euler(-1.58, -1.5707963267948966, 0), 1.2) 
            rightHip.C0 = rightHip.C0:Lerp(cf(0.5, -3.5, -2) * euler(-1.58, 1.5707963267948966, 0), 0.2) 
  elseif mode == "emote" then
            neck.C0 = neck.C0:Lerp(cf(0, 0, 0) * euler(-1.5882496193148399, 0, -3.1590459461097367), 0.2) 
            rootJoint.C0 = rootJoint.C0:Lerp(cf(0, -3, 0) * euler(-1.5707963267948966, 0, -3.141592653589793), 0.2) 
            leftShoulder.C0 = leftShoulder.C0:Lerp(cf(0.5, 2.2, 0) * euler(0, -1.5707963267948966, 0), 0.2) 
            rightShoulder.C0 = rightShoulder.C0:Lerp(cf(-0.5, 4.3, 0.02) * euler(0, 1.5707963267948966, 0), 0.2) 
            leftHip.C0 = leftHip.C0:Lerp(cf(-0.5, -3.5, -3.3) * euler(-1.58, -1.5707963267948966, 0), 1.2) 
            rightHip.C0 = rightHip.C0:Lerp(cf(0.5, -3.5, -2) * euler(-1.58, 1.5707963267948966, 0), 0.2) 
            
  end
    end
end

end)

local FirstButton = FirstPage.AddButton("Small PP", function()

local A_1 = ";morph me Slender "
local Event = game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand
Event:InvokeServer(A_1)
 
local A_1 = "Authenticate"
local Event = game:GetService("Workspace").Boards.SettingsHandler.Retriever
Event:InvokeServer(A_1)
 
local A_1 = ";morph me Noob1 "
local Event = game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand
Event:InvokeServer(A_1)
 
local A_1 = ";char me nato1231231Qw"
local Event = game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand
Event:InvokeServer(A_1)
    wait(2)

    local args = {
        [1] = ";hat me 4997844664"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)

    local args = {
        [1] = ";hat me 4997846903"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)

    local args = {
        [1] = ";hat me 6114844034"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)

    local args = {
        [1] = ";hat me 6114849049"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)

    local args = {
        [1] = ";hat me 6114875330"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(.4)

    local args = {
        [1] = ";hat me 6114870953"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)

    local args = {
        [1] = ";hat me 63690008"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)
    
loadstring(game:HttpGet("https://pastebin.com/raw/jR00xfMW"))()
wait(1)
    
    character = game:GetService("Players").LocalPlayer.Character

	rightArm = character:FindFirstChild("Right Arm")
	if rightArm then rightArm:Destroy() end
	wait(.4)

local tog = true
local jit = Vector3.new(25.01,0,0)
local Player = game:GetService("Players").LocalPlayer
local Character = Player.Character

game.Players.LocalPlayer.Character["macaron"].Name = "Bob1"
game.Players.LocalPlayer.Character["macaron"].Name = "Bob2"

game.RunService.Heartbeat:Connect(function()
Character["CaramelBear"].Handle.Velocity = jit
Character["FrostedBear"].Handle.Velocity = jit
Character["Bob1"].Handle.Velocity = jit
Character["SnowCookie"].Handle.Velocity = jit
Character["Bob2"].Velocity = jit
Character["SnowCookieRed"].Handle.Velocity = jit
Character["Pal Hair"].Handle.Velocity = jit
end)

local GR = Instance.new("Model",Character)
Character.Model.Name = "Hand"

local hh = Character.Hand
local pr = Instance.new("Part",hh)
local pr = Instance.new("Part",hh)
local pr = Instance.new("Part",hh)
local pr = Instance.new("Part",hh)
local pr = Instance.new("Part",hh)
local pr = Instance.new("Part",hh)
local pr = Instance.new("Part",hh)

hh:FindFirstChild("Part").Name = "pr1"
hh:FindFirstChild("Part").Name = "pr2"
hh:FindFirstChild("Part").Name = "pr3"
hh:FindFirstChild("Part").Name = "pr4"
hh:FindFirstChild("Part").Name = "pr5"
hh:FindFirstChild("Part").Name = "pr6"
hh:FindFirstChild("Part").Name = "pr7"

hh.pr1.Size = Vector3.new(5,3,1)
hh.pr2.Size = Vector3.new(1,1,2)
hh.pr3.Size = Vector3.new(1,1,2)
hh.pr4.Size = Vector3.new(1,1,2)
hh.pr5.Size = Vector3.new(1,1,2)
hh.pr6.Size = Vector3.new(1,1,2)
hh.pr7.Size = Vector3.new(1,1,2)

for i,v in pairs (Character.Hand:GetChildren()) do
    if v:IsA("Part") then
        v.CanCollide = false
        v.Transparency = 1
        v.CFrame = Character.HumanoidRootPart.CFrame
    end
end

local Hats = {palm   = Character:WaitForChild("CaramelBear"),
             point1   = Character:WaitForChild("FrostedBear"),
             point2   = Character:WaitForChild("Bob1"),
             middle1   = Character:WaitForChild("SnowCookie"),
             middle2   = Character:WaitForChild("Bob2"),
             ring1   = Character:WaitForChild("SnowCookieRed"),
             ring2   = Character:WaitForChild("Pal Hair"),             
}

for i,v in next, Hats do
v.Handle.AccessoryWeld:Remove()
for _,mesh in next, v:GetDescendants() do
if mesh:IsA("Mesh") or mesh:IsA("SpecialMesh") then
mesh:Remove()
end
end
end

local function align(i,v)
local att0 = Instance.new("Attachment", i)
att0.Position = Vector3.new(0,0,0)
local att1 = Instance.new("Attachment", v)
att1.Position = Vector3.new(0,0,0)
local AP = Instance.new("AlignPosition", i)
AP.Attachment0 = att0
AP.Attachment1 = att1
AP.RigidityEnabled = false
AP.ReactionForceEnabled = false
AP.ApplyAtCenterOfMass = true
AP.MaxForce = 9999999
AP.MaxVelocity = math.huge
AP.Responsiveness = 65
local AO = Instance.new("AlignOrientation", i)
AO.Attachment0 = att0
AO.Attachment1 = att1
AO.ReactionTorqueEnabled = false
AO.PrimaryAxisOnly = false
AO.MaxTorque = 9999999
AO.MaxAngularVelocity = math.huge
AO.Responsiveness = 50
end
align(Hats.palm.Handle,hh.pr1)
align(Hats.point1.Handle,hh.pr2)
align(Hats.point2.Handle,hh.pr3)
align(Hats.middle1.Handle,hh.pr4)
align(Hats.middle2.Handle,hh.pr5)
align(Hats.ring1.Handle,hh.pr6)
align(Hats.ring2.Handle,hh.pr7)
hh.pr1.Attachment.Name = "a1"
hh.pr2.Attachment.Name = "a2"
hh.pr3.Attachment.Name = "a3"
hh.pr4.Attachment.Name = "a4"
hh.pr5.Attachment.Name = "a5"
hh.pr6.Attachment.Name = "a6"
hh.pr7.Attachment.Name = "a7"

align(hh.pr1, Character["HumanoidRootPart"])
align(hh.pr2, Character["HumanoidRootPart"])
align(hh.pr3, Character["HumanoidRootPart"])
align(hh.pr4, Character["HumanoidRootPart"])
align(hh.pr5, Character["HumanoidRootPart"])
align(hh.pr6, Character["HumanoidRootPart"])
align(hh.pr7, Character["HumanoidRootPart"])

hh.pr1.Attachment.Rotation = Vector3.new(0,90,0)
hh.pr2.Attachment.Rotation = Vector3.new(0,90,0)
hh.pr3.Attachment.Rotation = Vector3.new(0,90,0)
hh.pr4.Attachment.Rotation = Vector3.new(0,90,0)
hh.pr5.Attachment.Rotation = Vector3.new(0,90,0)
hh.pr6.Attachment.Rotation = Vector3.new(0,90,0)
hh.pr7.Attachment.Rotation = Vector3.new(90,0,0)

Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment1"
Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment2"
Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment3"
Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment4"
Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment5"
Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment6"
Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment7"

Character:WaitForChild("HumanoidRootPart").Attachment1.Position = Vector3.new(-0,-1,-1)
Character:WaitForChild("HumanoidRootPart").Attachment2.Position = Vector3.new(-0,-1,-2)
Character:WaitForChild("HumanoidRootPart").Attachment3.Position = Vector3.new(-0.3,-1.3,-0.5)
Character:WaitForChild("HumanoidRootPart").Attachment4.Position = Vector3.new(-0,-1,-2)
Character:WaitForChild("HumanoidRootPart").Attachment5.Position = Vector3.new(0.3,-1.3,-0.5)
Character:WaitForChild("HumanoidRootPart").Attachment6.Position = Vector3.new(-0,-1,-2)
Character:WaitForChild("HumanoidRootPart").Attachment7.Position = Vector3.new(1.5,-0.050,0)


game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(KeyPressed)
 if KeyPressed == "e" then
     if toggle == false then

               Character:WaitForChild("HumanoidRootPart").Attachment1.Position = Vector3.new(-0,-1,-1)
Character:WaitForChild("HumanoidRootPart").Attachment2.Position = Vector3.new(-0,-1,-2)
Character:WaitForChild("HumanoidRootPart").Attachment3.Position = Vector3.new(-0.3,-1.3,-0.5)
Character:WaitForChild("HumanoidRootPart").Attachment4.Position = Vector3.new(-0,-1,-2)
Character:WaitForChild("HumanoidRootPart").Attachment5.Position = Vector3.new(0.3,-1.3,-0.5)
Character:WaitForChild("HumanoidRootPart").Attachment6.Position = Vector3.new(-0,-1,-2)
Character:WaitForChild("HumanoidRootPart").Attachment7.Position = Vector3.new(1.5,-0.050,0)

		    hh.pr1.Attachment.Rotation = Vector3.new(0,90,0)
                hh.pr2.Attachment.Rotation = Vector3.new(0,90,0)
                hh.pr3.Attachment.Rotation = Vector3.new(0,90,0)
                hh.pr4.Attachment.Rotation = Vector3.new(0,90,0)
                hh.pr5.Attachment.Rotation = Vector3.new(0,90,0)
                hh.pr6.Attachment.Rotation = Vector3.new(0,90,0)
                hh.pr7.Attachment.Rotation = Vector3.new(90,0,0)
                
           toggle = true
 else
 
Character:WaitForChild("HumanoidRootPart").Attachment1.Position = Vector3.new(-0,-1,-1)
Character:WaitForChild("HumanoidRootPart").Attachment2.Position = Vector3.new(-0,-1,-2)
Character:WaitForChild("HumanoidRootPart").Attachment3.Position = Vector3.new(-0.3,-1.3,-0.5)
Character:WaitForChild("HumanoidRootPart").Attachment4.Position = Vector3.new(-0,-1,-3)
Character:WaitForChild("HumanoidRootPart").Attachment5.Position = Vector3.new(0.3,-1.3,-0.5)
Character:WaitForChild("HumanoidRootPart").Attachment6.Position = Vector3.new(-0,-1,-3.8)
Character:WaitForChild("HumanoidRootPart").Attachment7.Position = Vector3.new(1.5,-0.050,0)

		    hh.pr1.Attachment.Rotation = Vector3.new(0,90,0)
                hh.pr2.Attachment.Rotation = Vector3.new(0,90,0)
                hh.pr3.Attachment.Rotation = Vector3.new(0,90,0)
                hh.pr4.Attachment.Rotation = Vector3.new(0,90,0)
                hh.pr5.Attachment.Rotation = Vector3.new(0,90,0)
                hh.pr6.Attachment.Rotation = Vector3.new(0,90,0)
                hh.pr7.Attachment.Rotation = Vector3.new(90,0,0)

            toggle = false
        end
    end
end)


game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(KeyPressed)
    if KeyPressed == "q" then
        if toggle == false then
   
   Character:WaitForChild("HumanoidRootPart").Attachment7.Position = Vector3.new(1.1,-0.050,-1.1)
   
                   hh.pr7.Attachment.Rotation = Vector3.new(50,-34,0)
                   
              toggle = true
    else
    
Character:WaitForChild("HumanoidRootPart").Attachment7.Position = Vector3.new(1.1,-0.050,-0.8)
   
                   hh.pr7.Attachment.Rotation = Vector3.new(50,-56,0)
   
               toggle = false
           end
       end
end)

while true do 
Hats.palm.Handle.CFrame = hh.pr1.CFrame
Hats.point1.Handle.CFrame = hh.pr2.CFrame
Hats.point2.Handle.CFrame = hh.pr3.CFrame
Hats.middle1.Handle.CFrame = hh.pr4.CFrame
Hats.middle2.Handle.CFrame = hh.pr5.CFrame
Hats.ring1.Handle.CFrame = hh.pr6.CFrame
Hats.ring2.Handle.CFrame = hh.pr7.CFrame
wait()
end
end)

local FirstButton = FirstPage.AddButton("Big PP", function()

local A_1 = ";morph me Slender "
local Event = game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand
Event:InvokeServer(A_1)
 
local A_1 = "Authenticate"
local Event = game:GetService("Workspace").Boards.SettingsHandler.Retriever
Event:InvokeServer(A_1)
 
local A_1 = ";morph me Noob1 "
local Event = game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand
Event:InvokeServer(A_1)
 
local A_1 = ";char me nato1231231Qw"
local Event = game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand
Event:InvokeServer(A_1)
    wait(2)

    local args = {
        [1] = ";hat me 17614451"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)

    local args = {
        [1] = ";hat me 63690008"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)

    local args = {
        [1] = ";hat me 376527500"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)

    local args = {
        [1] = ";hat me 62724852"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)

    local args = {
        [1] = ";hat me 62234425"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(.4)

    local args = {
        [1] = ";hat me 376524487"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)
    
    local args = {
        [1] = ";hat me 376526673"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)
    
    loadstring(game:HttpGet("https://pastebin.com/raw/jR00xfMW"))()
    wait(.5)
    
game.StarterGui:SetCore("SendNotification", {
Title = "!";
Text = "Wait 2 Second";
})
wait(2)
local tog = true
local move = false
local jit = Vector3.new(25.01,0,0)
local Player = game:GetService("Players").LocalPlayer
local Character = Player.Character

game.RunService.Heartbeat:Connect(function()
Character["Hat1"].Handle.Velocity = jit
Character["Kate Hair"].Handle.Velocity = jit
Character["MessyHair"].Handle.Velocity = jit
Character["Pal Hair"].Handle.Velocity = jit
Character["Mushroom"].Handle.Velocity = jit
Character["VarietyShades02"].Handle.Velocity = jit
Character["VarietyShades10"].Handle.Velocity = jit
end)

local tip = "Mushroom"
local x = -4 
local y = 0.2
local z = 0


local Hats = {palm   = Character:WaitForChild("Hat1"),
             point1   = Character:WaitForChild("Kate Hair"),
             point2   = Character:WaitForChild("MessyHair"),
             middle1   = Character:WaitForChild("Pal Hair"),
             ring1   = Character:WaitForChild("VarietyShades02"),
             ring2   = Character:WaitForChild("VarietyShades10"),
}

local GR = Instance.new("Model",Character)
Character.Model.Name = "Hand"

local hh = Character.Hand
local pr = Instance.new("Part",hh)
local pr = Instance.new("Part",hh)
local pr = Instance.new("Part",hh)
local pr = Instance.new("Part",hh)
local pr = Instance.new("Part",hh)
local pr = Instance.new("Part",hh)

hh:FindFirstChild("Part").Name = "pr1"
hh:FindFirstChild("Part").Name = "pr2"
hh:FindFirstChild("Part").Name = "pr3"
hh:FindFirstChild("Part").Name = "pr4"
hh:FindFirstChild("Part").Name = "pr6"
hh:FindFirstChild("Part").Name = "pr7"

hh.pr1.Size = Vector3.new(5,3,1)
hh.pr2.Size = Vector3.new(1,1,2)
hh.pr3.Size = Vector3.new(1,1,2)
hh.pr4.Size = Vector3.new(1,1,2)
hh.pr6.Size = Vector3.new(1,1,2)
hh.pr7.Size = Vector3.new(1,1,2)

for i,v in pairs (Character.Hand:GetChildren()) do
    if v:IsA("Part") then
        v.CanCollide = false
        v.Transparency = 1
        v.CFrame = Character.HumanoidRootPart.CFrame
    end
end

for i,v in next, Hats do
v.Handle.AccessoryWeld:Remove()
for _,mesh in next, v:GetDescendants() do
if mesh:IsA("Mesh") or mesh:IsA("SpecialMesh") then
mesh:Remove()
end
end
end

local function align(i,v)
local att0 = Instance.new("Attachment", i)
att0.Position = Vector3.new(0,0,0)
local att1 = Instance.new("Attachment", v)
att1.Position = Vector3.new(0,0,0)
local AP = Instance.new("AlignPosition", i)
AP.Attachment0 = att0
AP.Attachment1 = att1
AP.RigidityEnabled = false
AP.ReactionForceEnabled = false
AP.ApplyAtCenterOfMass = true
AP.MaxForce = 9999999
AP.MaxVelocity = math.huge
AP.Responsiveness = 65
local AO = Instance.new("AlignOrientation", i)
AO.Attachment0 = att0
AO.Attachment1 = att1
AO.ReactionTorqueEnabled = false
AO.PrimaryAxisOnly = false
AO.MaxTorque = 9999999
AO.MaxAngularVelocity = math.huge
AO.Responsiveness = 50
end
align(Hats.palm.Handle,hh.pr1)
align(Hats.point1.Handle,hh.pr2)
align(Hats.point2.Handle,hh.pr3)
align(Hats.middle1.Handle,hh.pr4)
align(Hats.ring1.Handle,hh.pr6)
align(Hats.ring2.Handle,hh.pr7)
hh.pr1.Attachment.Name = "a1"
hh.pr2.Attachment.Name = "a2"
hh.pr3.Attachment.Name = "a3"
hh.pr4.Attachment.Name = "a4"
hh.pr6.Attachment.Name = "a6"
hh.pr7.Attachment.Name = "a7"

align(hh.pr1, Character["HumanoidRootPart"])
align(hh.pr2, Character["HumanoidRootPart"])
align(hh.pr3, Character["HumanoidRootPart"])
align(hh.pr4, Character["HumanoidRootPart"])
align(hh.pr6, Character["HumanoidRootPart"])
align(hh.pr7, Character["HumanoidRootPart"])

hh.pr1.Attachment.Rotation = Vector3.new(40,0,0)
hh.pr2.Attachment.Rotation = Vector3.new(20,0,0)
hh.pr3.Attachment.Rotation = Vector3.new(20,0,0)
hh.pr4.Attachment.Rotation = Vector3.new(40,0,0)
hh.pr6.Attachment.Rotation = Vector3.new(82,0,0)
hh.pr7.Attachment.Rotation = Vector3.new(82,0,0)

Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment1"
Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment2"
Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment3"
Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment4"
Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment6"
Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment7"

Character:WaitForChild("HumanoidRootPart").Attachment1.Position = Vector3.new(0,-1.6,-1.3)
Character:WaitForChild("HumanoidRootPart").Attachment2.Position = Vector3.new(0,-2.2,-2.4)
Character:WaitForChild("HumanoidRootPart").Attachment3.Position = Vector3.new(0,-2.2,-2.4)
Character:WaitForChild("HumanoidRootPart").Attachment4.Position = Vector3.new(0,-1.6,-1.3)
Character:WaitForChild("HumanoidRootPart").Attachment6.Position = Vector3.new(-0.3,-1.5,-0.6)
Character:WaitForChild("HumanoidRootPart").Attachment7.Position = Vector3.new(0.3,-1.5,-0.6)


Character:WaitForChild(tip).Handle.AccessoryWeld:Remove()
local alignpos = Instance.new("AlignPosition", Character)
local alignorien = Instance.new("AlignOrientation", Character)
local att1 = Instance.new("Attachment", Character:WaitForChild(tip).Handle)
local att2 = Instance.new("Attachment", Character:WaitForChild("HumanoidRootPart"))
alignpos.Attachment0 = att1
alignpos.Attachment1 = att2
alignpos.RigidityEnabled = false
alignpos.ReactionForceEnabled = false
alignpos.ApplyAtCenterOfMass = true
alignpos.MaxForce = 99999999
alignpos.MaxVelocity = math.huge
alignpos.Responsiveness = 200
alignorien.Attachment0 = att1
alignorien.Attachment1 = att2
alignorien.ReactionTorqueEnabled = false
alignorien.PrimaryAxisOnly = false
alignorien.MaxTorque = 99999999
alignorien.MaxAngularVelocity = math.huge
alignorien.Responsiveness = 200
att2.Position = Vector3.new(x,y,z)

            att2.Position = Vector3.new(0,-2.7,-4)
            att2.Rotation = Vector3.new(-105,0,0)

game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(KeyPressed)
 if KeyPressed == "q" then
     if toggle == false then
         
         Character.Humanoid.WalkSpeed = 16
         
         Character.Humanoid.Sit = false
         
         Character.Torso.Anchored = false
         
                     Character.Humanoid.HipHeight = 0
Character:WaitForChild("HumanoidRootPart").Attachment1.Position = Vector3.new(0,-1.6,-1.3)
Character:WaitForChild("HumanoidRootPart").Attachment2.Position = Vector3.new(0,-2.2,-2.4)
Character:WaitForChild("HumanoidRootPart").Attachment3.Position = Vector3.new(0,-2.2,-2.4)
Character:WaitForChild("HumanoidRootPart").Attachment4.Position = Vector3.new(0,-1.6,-1.3)
Character:WaitForChild("HumanoidRootPart").Attachment6.Position = Vector3.new(-0.3,-1.5,-0.6)
Character:WaitForChild("HumanoidRootPart").Attachment7.Position = Vector3.new(0.3,-1.5,-0.6)

hh.pr1.Attachment.Rotation = Vector3.new(40,0,0)
hh.pr2.Attachment.Rotation = Vector3.new(20,0,0)
hh.pr3.Attachment.Rotation = Vector3.new(20,0,0)
hh.pr4.Attachment.Rotation = Vector3.new(40,0,0)
hh.pr6.Attachment.Rotation = Vector3.new(82,0,0)
hh.pr7.Attachment.Rotation = Vector3.new(82,0,0)
                
                
            att2.Position = Vector3.new(0,-2.7,-4)
            att2.Rotation = Vector3.new(-105,0,0)
           toggle = true
 else
 
Character:WaitForChild("HumanoidRootPart").Attachment1.Position = Vector3.new(0,-1,-1.3)
Character:WaitForChild("HumanoidRootPart").Attachment2.Position = Vector3.new(0,-0.9,-3)
Character:WaitForChild("HumanoidRootPart").Attachment3.Position = Vector3.new(0,-0.8,-4.1)
Character:WaitForChild("HumanoidRootPart").Attachment4.Position = Vector3.new(0,-0.6,-5.3)
Character:WaitForChild("HumanoidRootPart").Attachment6.Position = Vector3.new(-0.3,-1.5,-0.6)
Character:WaitForChild("HumanoidRootPart").Attachment7.Position = Vector3.new(0.3,-1.5,-0.6)

		    hh.pr1.Attachment.Rotation = Vector3.new(0,0,0)
                hh.pr2.Attachment.Rotation = Vector3.new(-6,0,0)
                hh.pr3.Attachment.Rotation = Vector3.new(-8,0,0)
                hh.pr4.Attachment.Rotation = Vector3.new(-11,0,0)
                hh.pr6.Attachment.Rotation = Vector3.new(82,0,0)
                hh.pr7.Attachment.Rotation = Vector3.new(82,0,0)
                
                
            att2.Position = Vector3.new(0,-0.2,-6.9)
            att2.Rotation = Vector3.new(-75,0,0)
            toggle = false
        end
    end
end)

while true do 
Hats.palm.Handle.CFrame = hh.pr1.CFrame
Hats.point1.Handle.CFrame = hh.pr2.CFrame
Hats.point2.Handle.CFrame = hh.pr3.CFrame
Hats.middle1.Handle.CFrame = hh.pr4.CFrame
Hats.ring1.Handle.CFrame = hh.pr6.CFrame
Hats.ring2.Handle.CFrame = hh.pr7.CFrame
wait()
end
end)

local FirstButton = FirstPage.AddButton("Sex Doll", function()
local A_1 = ";morph me Slender "
local Event = game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand
Event:InvokeServer(A_1)
 
local A_1 = "Authenticate"
local Event = game:GetService("Workspace").Boards.SettingsHandler.Retriever
Event:InvokeServer(A_1)
 
local A_1 = ";morph me Noob1 "
local Event = game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand
Event:InvokeServer(A_1)
 
local A_1 = ";char me nato1231231Qw"
local Event = game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand
Event:InvokeServer(A_1)
    wait(2)

    local args = {
        [1] = ";hat me 451220849"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)

    local args = {
        [1] = ";hat me 62234425"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)

    local args = {
        [1] = ";hat me 63690008"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)

    local args = {
        [1] = ";hat me 14815761"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)

    local args = {
        [1] = ";hat me 48474294"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(.4)

    local args = {
        [1] = ";hat me 20011897"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)
    
        local args = {
        [1] = ";hat me 12548563"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)
        
        local args = {
        [1] = ";hat me 6211939438"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)
    
            local args = {
        [1] = ";hat me 7097874494"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)
    
    loadstring(game:HttpGet("https://pastebin.com/raw/jR00xfMW"))()
    wait(.2)
    
game.StarterGui:SetCore("SendNotification", {
Title = "!";
Text = "Wait 2 Second";
})
wait(2)
local tog = true
local jit = Vector3.new(25.01,0,0)
local Player = game:GetService("Players").LocalPlayer
local Character = Player.Character

game.RunService.Heartbeat:Connect(function()
Character["Pal Hair"].Handle.Velocity = jit
Character["Hat1"].Handle.Velocity = jit
Character["Space Cop"].Handle.Velocity = jit
Character["SpaceHelmetB"].Handle.Velocity = jit
Character["LongHairHeadBand Black"].Handle.Velocity = jit
Character["LavanderHair"].Handle.Velocity = jit
Character["Pink Hair"].Handle.Velocity = jit
Character["LooseSideBuns"].Handle.Velocity = jit
Character["Cute  Expressive Mask"].Handle.Velocity = jit
end)

local Head = "LooseSideBuns" --press f9 and find the hat that looks like a heads name and put it here
local x = -4   --Edit Position for head n +left and -Right
local y = 0.2   --Edit Position for head up and down
local z = 0 --Edit Position for head x3

local tip = "Cute  Expressive Mask" --press f9 and find the hat that looks like a heads name and put it here
local x = -4   --Edit Position for head n +left and -Right
local y = 0.2   --Edit Position for head up and down
local z = 0 --Edit Position for head x3

local Hats = {palm   = Character:WaitForChild("Pal Hair"),
             point1   = Character:WaitForChild("Hat1"),
             point2   = Character:WaitForChild("Space Cop"),
             middle1   = Character:WaitForChild("SpaceHelmetB"),
             middle2   = Character:WaitForChild("LongHairHeadBand Black"),
             ring1   = Character:WaitForChild("LavanderHair"),
             ring2   = Character:WaitForChild("Pink Hair"),
}


local GR = Instance.new("Model",Character)
Character.Model.Name = "Hand"

local hh = Character.Hand
local pr = Instance.new("Part",hh)
local pr = Instance.new("Part",hh)
local pr = Instance.new("Part",hh)
local pr = Instance.new("Part",hh)
local pr = Instance.new("Part",hh)
local pr = Instance.new("Part",hh)
local pr = Instance.new("Part",hh)


hh:FindFirstChild("Part").Name = "pr1"
hh:FindFirstChild("Part").Name = "pr2"
hh:FindFirstChild("Part").Name = "pr3"
hh:FindFirstChild("Part").Name = "pr4"
hh:FindFirstChild("Part").Name = "pr5"
hh:FindFirstChild("Part").Name = "pr6"
hh:FindFirstChild("Part").Name = "pr7"


hh.pr1.Size = Vector3.new(5,3,1)
hh.pr2.Size = Vector3.new(1,1,2)
hh.pr3.Size = Vector3.new(1,1,2)
hh.pr4.Size = Vector3.new(1,1,2)
hh.pr5.Size = Vector3.new(1,1,2)
hh.pr6.Size = Vector3.new(1,1,2)
hh.pr7.Size = Vector3.new(1,1,2)


for i,v in pairs (Character.Hand:GetChildren()) do
    if v:IsA("Part") then
        v.CanCollide = false
        v.Transparency = 1
        v.CFrame = Character.HumanoidRootPart.CFrame
    end
end


for i,v in next, Hats do
v.Handle.AccessoryWeld:Remove()
for _,mesh in next, v:GetDescendants() do
if mesh:IsA("Mesh") or mesh:IsA("SpecialMesh") then
mesh:Remove()
end
end
end

local function align(i,v)
local att0 = Instance.new("Attachment", i)
att0.Position = Vector3.new(0,0,0)
local att1 = Instance.new("Attachment", v)
att1.Position = Vector3.new(0,0,0)
local AP = Instance.new("AlignPosition", i)
AP.Attachment0 = att0
AP.Attachment1 = att1
AP.RigidityEnabled = false
AP.ReactionForceEnabled = false
AP.ApplyAtCenterOfMass = true
AP.MaxForce = 9999999
AP.MaxVelocity = math.huge
AP.Responsiveness = 65
local AO = Instance.new("AlignOrientation", i)
AO.Attachment0 = att0
AO.Attachment1 = att1
AO.ReactionTorqueEnabled = false
AO.PrimaryAxisOnly = false
AO.MaxTorque = 9999999
AO.MaxAngularVelocity = math.huge
AO.Responsiveness = 50
end
align(Hats.palm.Handle,hh.pr1)
align(Hats.point1.Handle,hh.pr2)
align(Hats.point2.Handle,hh.pr3)
align(Hats.middle1.Handle,hh.pr4)
align(Hats.middle2.Handle,hh.pr5)
align(Hats.ring1.Handle,hh.pr6)
align(Hats.ring2.Handle,hh.pr7)
hh.pr1.Attachment.Name = "a1"
hh.pr2.Attachment.Name = "a2"
hh.pr3.Attachment.Name = "a3"
hh.pr4.Attachment.Name = "a4"
hh.pr5.Attachment.Name = "a5"
hh.pr6.Attachment.Name = "a6"
hh.pr7.Attachment.Name = "a7"


align(hh.pr1, Character["HumanoidRootPart"])
align(hh.pr2, Character["HumanoidRootPart"])
align(hh.pr3, Character["HumanoidRootPart"])
align(hh.pr4, Character["HumanoidRootPart"])
align(hh.pr5, Character["HumanoidRootPart"])
align(hh.pr6, Character["HumanoidRootPart"])
align(hh.pr7, Character["HumanoidRootPart"])


		    hh.pr1.Attachment.Rotation = Vector3.new(-70,-10,0)
                hh.pr2.Attachment.Rotation = Vector3.new(-70,10,0)
                hh.pr3.Attachment.Rotation = Vector3.new(-80,-1,0)
                hh.pr4.Attachment.Rotation = Vector3.new(-80,-1,0)
                hh.pr5.Attachment.Rotation = Vector3.new(90,-1,90)
                hh.pr6.Attachment.Rotation = Vector3.new(90,-22,0)
                hh.pr7.Attachment.Rotation = Vector3.new(90,22,0)


Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment1"
Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment2"
Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment3"
Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment4"
Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment5"
Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment6"
Character:WaitForChild("HumanoidRootPart"):FindFirstChild("Attachment").Name = "Attachment7"

Character:WaitForChild("HumanoidRootPart").Attachment1.Position = Vector3.new(-0.9,-2,-1.3)
Character:WaitForChild("HumanoidRootPart").Attachment2.Position = Vector3.new(0.9,-2,-1.3)
Character:WaitForChild("HumanoidRootPart").Attachment3.Position = Vector3.new(-0.6,-1.1,-1.4)
Character:WaitForChild("HumanoidRootPart").Attachment4.Position = Vector3.new(0.6,-1.1,-1.4)
Character:WaitForChild("HumanoidRootPart").Attachment5.Position = Vector3.new(0,-1.3,-2.9)
Character:WaitForChild("HumanoidRootPart").Attachment6.Position = Vector3.new(-1,-2,-4)
Character:WaitForChild("HumanoidRootPart").Attachment7.Position = Vector3.new(1,-2,-4)

Character:WaitForChild(Head).Handle.AccessoryWeld:Remove()
local alignpos = Instance.new("AlignPosition", Character)
local alignorien = Instance.new("AlignOrientation", Character)
local att1 = Instance.new("Attachment", Character:WaitForChild(Head).Handle)
local att2 = Instance.new("Attachment", Character:WaitForChild("Head"))
alignpos.Attachment0 = att1
alignpos.Attachment1 = att2
alignpos.RigidityEnabled = false
alignpos.ReactionForceEnabled = false
alignpos.ApplyAtCenterOfMass = true
alignpos.MaxForce = 99999999
alignpos.MaxVelocity = math.huge
alignpos.Responsiveness = 200
alignorien.Attachment0 = att1
alignorien.Attachment1 = att2
alignorien.ReactionTorqueEnabled = false
alignorien.PrimaryAxisOnly = false
alignorien.MaxTorque = 99999999
alignorien.MaxAngularVelocity = math.huge
alignorien.Responsiveness = 200
att2.Position = Vector3.new(x,y,z)

Character:WaitForChild(tip).Handle.AccessoryWeld:Remove()
local alignpos = Instance.new("AlignPosition", Character)
local alignorien = Instance.new("AlignOrientation", Character)
local att3 = Instance.new("Attachment", Character:WaitForChild(tip).Handle)
local att4 = Instance.new("Attachment", Character:WaitForChild("Head"))
alignpos.Attachment0 = att3
alignpos.Attachment1 = att4
alignpos.RigidityEnabled = false
alignpos.ReactionForceEnabled = false
alignpos.ApplyAtCenterOfMass = true
alignpos.MaxForce = 99999999
alignpos.MaxVelocity = math.huge
alignpos.Responsiveness = 200
alignorien.Attachment0 = att3
alignorien.Attachment1 = att4
alignorien.ReactionTorqueEnabled = false
alignorien.PrimaryAxisOnly = false
alignorien.MaxTorque = 99999999
alignorien.MaxAngularVelocity = math.huge
alignorien.Responsiveness = 200
att2.Position = Vector3.new(x,y,z)

                att2.Position = Vector3.new(0,-2.6,-4)
                att2.Rotation = Vector3.new(-70,0,0)
                
                att4.Position = Vector3.new(0.047,-2.55,-4.6)
                att4.Rotation = Vector3.new(-70,0,0)

game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(KeyPressed)
 if KeyPressed == "x" then
     if toggle == false then
         
         Character.Humanoid.WalkSpeed = 16
         
         Character.Humanoid.Sit = false
         
         Character.Torso.Anchored = false
         
            Character.Humanoid.HipHeight = 0
                Character:WaitForChild("HumanoidRootPart").Attachment1.Position = Vector3.new(-0.9,-2,-1.3)
                Character:WaitForChild("HumanoidRootPart").Attachment2.Position = Vector3.new(0.9,-2,-1.3)
                Character:WaitForChild("HumanoidRootPart").Attachment3.Position = Vector3.new(-0.6,-1.1,-0.9)
                Character:WaitForChild("HumanoidRootPart").Attachment4.Position = Vector3.new(0.6,-1.1,-0.9)
                Character:WaitForChild("HumanoidRootPart").Attachment5.Position = Vector3.new(0,-1.3,-2.3)
                Character:WaitForChild("HumanoidRootPart").Attachment6.Position = Vector3.new(-1,-2,-3.5)
                Character:WaitForChild("HumanoidRootPart").Attachment7.Position = Vector3.new(1,-2,-3.5)

                
                
		    hh.pr1.Attachment.Rotation = Vector3.new(-90,22,0)
                hh.pr2.Attachment.Rotation = Vector3.new(-90,-22,0)
                hh.pr3.Attachment.Rotation = Vector3.new(-90,-1,0)
                hh.pr4.Attachment.Rotation = Vector3.new(-90,-1,0)
                hh.pr5.Attachment.Rotation = Vector3.new(90,-1,90)
                hh.pr6.Attachment.Rotation = Vector3.new(70,-10,0)
                hh.pr7.Attachment.Rotation = Vector3.new(70,10,0)                              
                

                att2.Position = Vector3.new(0,-2.6,-3.6)
                att2.Rotation = Vector3.new(-70,0,0)
                
                att4.Position = Vector3.new(0.047,-2.55,-4.2)
                att4.Rotation = Vector3.new(-70,0,0)            
           toggle = true
 else
Character:WaitForChild("HumanoidRootPart").Attachment1.Position = Vector3.new(-0.9,-2,-1.3)
Character:WaitForChild("HumanoidRootPart").Attachment2.Position = Vector3.new(0.9,-2,-1.3)
Character:WaitForChild("HumanoidRootPart").Attachment3.Position = Vector3.new(-0.6,-1.1,-1.4)
Character:WaitForChild("HumanoidRootPart").Attachment4.Position = Vector3.new(0.6,-1.1,-1.4)
Character:WaitForChild("HumanoidRootPart").Attachment5.Position = Vector3.new(0,-1.3,-2.9)
Character:WaitForChild("HumanoidRootPart").Attachment6.Position = Vector3.new(-1,-2,-4)
Character:WaitForChild("HumanoidRootPart").Attachment7.Position = Vector3.new(1,-2,-4)

                
		    hh.pr1.Attachment.Rotation = Vector3.new(-70,-10,0)
                hh.pr2.Attachment.Rotation = Vector3.new(-70,10,0)
                hh.pr3.Attachment.Rotation = Vector3.new(-80,-1,0)
                hh.pr4.Attachment.Rotation = Vector3.new(-80,-1,0)
                hh.pr5.Attachment.Rotation = Vector3.new(90,-1,90)
                hh.pr6.Attachment.Rotation = Vector3.new(90,-22,0)
                hh.pr7.Attachment.Rotation = Vector3.new(90,22,0)
                
                att2.Position = Vector3.new(0,-2.6,-4)
                att2.Rotation = Vector3.new(-70,0,0)
                
                att4.Position = Vector3.new(0.047,-2.55,-4.6)
                att4.Rotation = Vector3.new(-70,0,0)
                
            toggle = false
           
        end
    end
end)

game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(KeyPressed)
 if KeyPressed == "c" then
     if toggle == false then
         
         Character.Humanoid.WalkSpeed = 16
         
         Character.Humanoid.Sit = false
         
         Character.Torso.Anchored = false
         
            Character.Humanoid.HipHeight = 0
                Character:WaitForChild("HumanoidRootPart").Attachment1.Position = Vector3.new(-0.9,-2,-1.3)
                Character:WaitForChild("HumanoidRootPart").Attachment2.Position = Vector3.new(0.9,-2,-1.3)
                Character:WaitForChild("HumanoidRootPart").Attachment3.Position = Vector3.new(-0.6,-1.1,-0.9)
                Character:WaitForChild("HumanoidRootPart").Attachment4.Position = Vector3.new(0.6,-1.1,-0.9)
                Character:WaitForChild("HumanoidRootPart").Attachment5.Position = Vector3.new(0,-1.9,-2.5)
                Character:WaitForChild("HumanoidRootPart").Attachment6.Position = Vector3.new(-1.1,-2.4,-4.1)
                Character:WaitForChild("HumanoidRootPart").Attachment7.Position = Vector3.new(1,-2.6,-4.1)
                
                
hh.pr1.Attachment.Rotation = Vector3.new(-85,-10,0)
hh.pr2.Attachment.Rotation = Vector3.new(-85,10,0)
hh.pr3.Attachment.Rotation = Vector3.new(-80,-1,0)
hh.pr4.Attachment.Rotation = Vector3.new(-80,-1,0)
hh.pr5.Attachment.Rotation = Vector3.new(0,30,90)
hh.pr6.Attachment.Rotation = Vector3.new(10,30,0)
hh.pr7.Attachment.Rotation = Vector3.new(20,-17,0)                             
                

                att2.Position = Vector3.new(-0.187,-3.45,-3.6)
                att2.Rotation = Vector3.new(-50,-45,0)  
                
                att4.Position = Vector3.new(-0.055,-3.2,-4.1)
                att4.Rotation = Vector3.new(-40,-45,0) 
           toggle = true
 else
Character:WaitForChild("HumanoidRootPart").Attachment1.Position = Vector3.new(-0.9,-2,-1.3)
Character:WaitForChild("HumanoidRootPart").Attachment2.Position = Vector3.new(0.9,-2,-1.3)
Character:WaitForChild("HumanoidRootPart").Attachment3.Position = Vector3.new(-0.6,-1.1,-1.4)
Character:WaitForChild("HumanoidRootPart").Attachment4.Position = Vector3.new(0.6,-1.1,-1.4)
Character:WaitForChild("HumanoidRootPart").Attachment5.Position = Vector3.new(0,-1.9,-2.9)
Character:WaitForChild("HumanoidRootPart").Attachment6.Position = Vector3.new(-1.1,-2.4,-4.4)
Character:WaitForChild("HumanoidRootPart").Attachment7.Position = Vector3.new(1,-2.6,-4.4)

                
hh.pr1.Attachment.Rotation = Vector3.new(-70,-10,0)
hh.pr2.Attachment.Rotation = Vector3.new(-70,10,0)
hh.pr3.Attachment.Rotation = Vector3.new(-80,-1,0)
hh.pr4.Attachment.Rotation = Vector3.new(-80,-1,0)
hh.pr5.Attachment.Rotation = Vector3.new(0,30,90)
hh.pr6.Attachment.Rotation = Vector3.new(10,30,0)
hh.pr7.Attachment.Rotation = Vector3.new(20,-17,0)
                
                att2.Position = Vector3.new(-0.167,-3.45,-4)
                att2.Rotation = Vector3.new(-50,-45,0)
                
                att4.Position = Vector3.new(0,-3.2,-4.5)
                att4.Rotation = Vector3.new(-40,-45,0) 
                
            toggle = false
        end
    end
end)

game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(KeyPressed)
 if KeyPressed == "z" then
     if toggle == false then
         
         Character.Humanoid.WalkSpeed = 16
         
         Character.Humanoid.Sit = false
         
         Character.Torso.Anchored = false
         
            Character.Humanoid.HipHeight = 0
Character:WaitForChild("HumanoidRootPart").Attachment1.Position = Vector3.new(-0.7,-2.5,-2.3)
Character:WaitForChild("HumanoidRootPart").Attachment2.Position = Vector3.new(0.7,-2.5,-2.3)
Character:WaitForChild("HumanoidRootPart").Attachment3.Position = Vector3.new(-0.6,-2.4,-2.7)
Character:WaitForChild("HumanoidRootPart").Attachment4.Position = Vector3.new(0.6,-2.4,-2.7)
Character:WaitForChild("HumanoidRootPart").Attachment5.Position = Vector3.new(0,-1.4,-2)
Character:WaitForChild("HumanoidRootPart").Attachment6.Position = Vector3.new(-1.3,-0.7,-1.055)
Character:WaitForChild("HumanoidRootPart").Attachment7.Position = Vector3.new(1.3,-0.7,-1.055)

                
                
hh.pr1.Attachment.Rotation = Vector3.new(0,12,0)
hh.pr2.Attachment.Rotation = Vector3.new(0,-12,0)
hh.pr3.Attachment.Rotation = Vector3.new(0,0,0)
hh.pr4.Attachment.Rotation = Vector3.new(0,0,0)
hh.pr5.Attachment.Rotation = Vector3.new(90,-70,-90)
hh.pr6.Attachment.Rotation = Vector3.new(-5,-10,0)
hh.pr7.Attachment.Rotation = Vector3.new(-5,10,0)	                            
                

                att2.Position = Vector3.new(0,-1.8,-1.7)
                att2.Rotation = Vector3.new(25,180,0)

				att4.Position = Vector3.new(-0.047,-1.5,-1.3)
                att4.Rotation = Vector3.new(30,180,0)          
           toggle = true
 else
Character:WaitForChild("HumanoidRootPart").Attachment1.Position = Vector3.new(-0.7,-2.5,-2.2)
Character:WaitForChild("HumanoidRootPart").Attachment2.Position = Vector3.new(0.7,-2.5,-2.2)
Character:WaitForChild("HumanoidRootPart").Attachment3.Position = Vector3.new(-0.6,-2.4,-2.7)
Character:WaitForChild("HumanoidRootPart").Attachment4.Position = Vector3.new(0.6,-2.4,-2.7)
Character:WaitForChild("HumanoidRootPart").Attachment5.Position = Vector3.new(0,-1.4,-2)
Character:WaitForChild("HumanoidRootPart").Attachment6.Position = Vector3.new(-1.3,-0.5,-0.9)
Character:WaitForChild("HumanoidRootPart").Attachment7.Position = Vector3.new(1.3,-0.5,-0.9)

                
hh.pr1.Attachment.Rotation = Vector3.new(0,12,0)
hh.pr2.Attachment.Rotation = Vector3.new(0,-12,0)
hh.pr3.Attachment.Rotation = Vector3.new(0,0,0)
hh.pr4.Attachment.Rotation = Vector3.new(0,0,0)
hh.pr5.Attachment.Rotation = Vector3.new(90,-70,-90)
hh.pr6.Attachment.Rotation = Vector3.new(-5,-10,0)
hh.pr7.Attachment.Rotation = Vector3.new(-5,10,0)	
                
                att2.Position = Vector3.new(0,-2,-1.7)
                att2.Rotation = Vector3.new(30,180,0)

				att4.Position = Vector3.new(-0.047,-1.5,-1.3)
                att4.Rotation = Vector3.new(35,180,0)
                
            toggle = false
           
        end
    end
end)


while true do 
Hats.palm.Handle.CFrame = hh.pr1.CFrame
Hats.point1.Handle.CFrame = hh.pr2.CFrame
Hats.point2.Handle.CFrame = hh.pr3.CFrame
Hats.middle1.Handle.CFrame = hh.pr4.CFrame
Hats.middle2.Handle.CFrame = hh.pr5.CFrame
Hats.ring1.Handle.CFrame = hh.pr6.CFrame
Hats.ring2.Handle.CFrame = hh.pr7.CFrame
wait()
end
end)

local FirstButton = FirstPage.AddButton("Titan", function()
local A_1 = ";morph me Slender "
local Event = game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand
Event:InvokeServer(A_1)
 
local A_1 = "Authenticate"
local Event = game:GetService("Workspace").Boards.SettingsHandler.Retriever
Event:InvokeServer(A_1)
 
local A_1 = ";morph me Noob1 "
local Event = game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand
Event:InvokeServer(A_1)
 
local A_1 = ";char me nato1231231Qw"
local Event = game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand
Event:InvokeServer(A_1)
    wait(2)

    local args = {
        [1] = ";hat me 5919093961"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)

    local args = {
        [1] = ";hat me 4878136110"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)

    local args = {
        [1] = ";hat me 1744219293"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)

    local args = {
        [1] = ";hat me 18015906"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)

    local args = {
        [1] = ";hat me 1744235800"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(.4)

    local args = {
        [1] = ";hat me 1743941933"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(1)
    
    
for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
    if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
    game:GetService("RunService").Heartbeat:connect(function()
    v.Velocity = Vector3.new(-30,0,0)
    end)
    end
    end


local plr = game.Players.LocalPlayer
local char = plr.Character
local srv = game:GetService('RunService')
local ct = {}
local te = table.insert
local m = plr:GetMouse()
HumanDied=false 

--[[
Hats
-gh 5919093961,4878136110,1744219293,18015906,1744235800,1743941933
]]

_G.Jitter=Vector3.new(0,30,0)

char.Archivable = true
fl=Instance.new('Folder',char) fl.Name = 'Titan'
local reanim = char:Clone()
char.Humanoid:ChangeState(16)
char.Humanoid.RootPart:Destroy()

for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
if v:IsA("BasePart") and v.Name ~= 'Torso' and v.Name ~= 'Left Leg' then 
te(ct,game:GetService("RunService").Heartbeat:connect(function()
pcall(function()
if reanim.Humanoid.MoveDirection == Vector3.new(0,0,0) then
v.Velocity = _G.Jitter
else
v.AssemblyLinearVelocity = Vector3.new(reanim.Humanoid.MoveDirection.X*100,0,reanim.Humanoid.MoveDirection.Z*100)
end
game.Players.LocalPlayer.ReplicationFocus=workspace
sethiddenproperty(game.Players.LocalPlayer,"MaximumSimulationRadius",math.huge)
sethiddenproperty(game.Players.LocalPlayer,"SimulationRadius",9e9)
end)
end))
end
end

local Anim = Instance.new('Animation',char)
Anim.AnimationId='rbxassetid://121572214'
Anim.Name = 'HeadFloat'

dod=char.Humanoid:LoadAnimation(Anim)
dod:Play()

for i,v in next, char.Humanoid:GetPlayingAnimationTracks() do
if v.Name ~= 'HeadFloat' then
v:Stop()
end
end
char.Animate:Remove()

hats=0
function create(part, parent, p, r)
hats=hats+1
Instance.new("Attachment",part)
Instance.new("AlignPosition",part)
Instance.new("AlignOrientation",part)
Instance.new("Attachment",parent)
part.Attachment.Name = part.Name..hats
parent.Attachment.Name = part.Name..hats
part.AlignPosition.Attachment0 = part[part.Name..hats]
part.AlignOrientation.Attachment0 = part[part.Name..hats]
part.AlignPosition.Attachment1 = parent[part.Name..hats]
part.AlignOrientation.Attachment1 = parent[part.Name..hats]
parent[part.Name..hats].Position = p or Vector3.new()
part[part.Name..hats].Orientation = r or Vector3.new()
part.AlignPosition.MaxForce = 999999999
part.AlignPosition.MaxVelocity = math.huge
part.AlignPosition.ReactionForceEnabled = false
part.AlignPosition.Responsiveness = math.huge
part.AlignOrientation.Responsiveness = math.huge
part.AlignPosition.RigidityEnabled = false
part.AlignOrientation.MaxTorque = 999999999
force=Instance.new('BodyForce',part)
force.Force=Vector3.new(0,30,0)
end

function Pos(part, parent, p)
Instance.new("Attachment",part)
Instance.new("AlignPosition",part)
Instance.new("Attachment",parent)
part.Attachment.Name = part.Name
parent.Attachment.Name = part.Name
part.AlignPosition.Attachment0 = part[part.Name]
part.AlignPosition.Attachment1 = parent[part.Name]
parent[part.Name].Position = p or Vector3.new()
part.AlignPosition.MaxForce = 999999999*10
part.AlignPosition.MaxVelocity = math.huge
part.AlignPosition.ReactionForceEnabled = false
part.AlignPosition.Responsiveness = math.huge
part.AlignPosition.RigidityEnabled = false
end

function nc(p)
if p:IsA('BasePart') or p:IsA('Part') then
te(ct,srv.Stepped:Connect(function()
p.CanCollide=false
end))
te(ct,srv.RenderStepped:Connect(function()
p.CanCollide=false
end))
else
print('Cannot noclip '..p)
end
end

function af()
for i,v in next, game.Players:GetDescendants() do
if v:IsA('Player') and v.Name ~= game.Players.LocalPlayer.Name then
for _,c in next, v.Character:GetDescendants() do
if c:IsA('BasePart') and v.Parent== char then
noo=Instance.new('NoCollisionConstraint',c)
noo.Part1=char['Torso']
noo.Part0=c
noo2=Instance.new('NoCollisionConstraint',c)
noo2.Part1=char['Head']
noo2.Part0=c
end
end
end
end
end

for i,v in next, reanim:GetDescendants() do
if v:IsA('BasePart') or v:IsA('Decal') then
v.Transparency = 1
end
end

for i,v in next, char:GetDescendants() do
if v:IsA('BasePart') then
nc(v)
end
end

for i,v in next, char:GetDescendants() do
if v:IsA('Accessory') and v.Name ~= 'DreamCap' and v.Name ~= 'gradcap_18' and v.Name ~= 'Cyber Peacock Tail 2.0' and v.Name ~= 'PanicCap' and v.Name ~= 'Scarlett' then
v.Handle:BreakJoints()
create(v.Handle,reanim[v.Name].Handle)
end
end

function rm(p)
char:FindFirstChild(p).Handle:BreakJoints()
if char:FindFirstChild(p).Handle:FindFirstChild('Mesh') then
char:FindFirstChild(p).Handle.Mesh:Remove()
elseif char:FindFirstChild(p).Handle:FindFirstChild('SpecialMesh') then
char:FindFirstChild(p).Handle.SpecialMesh:Remove()
end
end

for i,v in next, reanim:GetDescendants() do
if v:IsA('BasePart') then
nc(v)
end
end

for i,v in next, char:GetDescendants() do
if v:IsA('Motor6D') and v.Name ~= 'Neck' then
v:Destroy()
end
end

for i,v in next, char:GetDescendants() do
if v:IsA('BasePart') and v.Name ~= 'Head' and v.Parent == char then
create(v,reanim[v.Name])
end
end

function flinger(p)
f=Instance.new('BodyAngularVelocity',p)
f.P=9e3*10
f.AngularVelocity = Vector3.new(9e9*10,9e9*10,9e9*10)
f.MaxTorque=Vector3.new(9e9*10,0,0)
end

create(char['Torso'],reanim['Torso'])

rm('PanicCap')
rm('DreamCap')
rm('gradcap_18')
rm('Scarlett')
rm('Cyber Peacock Tail 2.0')
create(char['PanicCap'].Handle,reanim['Right Leg'],Vector3.new(0,-0.5,0),Vector3.new(0,0,0))
create(char['gradcap_18'].Handle,reanim['Left Leg'],Vector3.new(0,-0.5,0),Vector3.new(0,0,0))
create(char['DreamCap'].Handle,reanim['Right Arm'],Vector3.new(0,-0.5,0),Vector3.new(0,0,0))
create(char['Scarlett'].Handle,reanim['Left Arm'],Vector3.new(0,-0.5,0),Vector3.new(0,0,0))
create(char['Cyber Peacock Tail 2.0'].Handle,reanim.Torso,Vector3.new(),Vector3.new(90,0,0))

reanim.Animate.Disabled=true

reanim.Parent=fl

plr.Character=reanim
workspace.Camera.CameraSubject=reanim

te(ct,char.Humanoid.Died:Connect(function()
create(char['Head'],reanim.Head)
end))

te(ct,reanim.Humanoid.Died:Connect(function()
HumanDied=true
reanim.HumanoidRootPart.Anchored=true
old=reanim.HumanoidRootPart.CFrame
reanim.HumanoidRootPart.CFrame=old
wait()
reanim.HumanoidRootPart.CFrame=old
char.Humanoid:Destroy()
Instance.new('Humanoid',char)
plr.Character=char
char:BreakJoints()
game.Players:Chat('-gr')
for i,v in next, ct do v:Disconnect() end
end))

sine=1
speed=1

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

RJ = reanim.HumanoidRootPart.RootJoint
RS = reanim.Torso['Right Shoulder']
LS = reanim.Torso['Left Shoulder']
RH = reanim.Torso['Right Hip']
LH = reanim.Torso['Left Hip']
Root = reanim.HumanoidRootPart
NECK = reanim.Torso.Neck
NECK.C0 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
NECK.C1 = CF(0,-0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RJ.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RJ.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RS.C1 = CF(-0.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LS.C1 = CF(0.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))

Mode='Normal'

run=plr:GetMouse().KeyDown:Connect(function(e)
if e == 'q' then
reanim.Humanoid.WalkSpeed=40
end
end)
run1=plr:GetMouse().KeyUp:Connect(function(e)
if e == 'z' then
reanim.Humanoid.WalkSpeed=16
end
end)

atk=plr:GetMouse().Button1Down:Connect(function(a)
if Mode == 'Stomp0' or Mode == 'Stomp1' then return end
wait(0.1)
Mode = 'Stomp0'
wait(0.4)
Mode='Stomp1'
wait(0.5)
Mode='Normal'
end)

doog=1
sp=1
te(ct,srv.Heartbeat:Connect(function()
doog=doog+sp
if Mode == 'Stomp1' then
char['Left Leg'].CFrame = reanim['Left Leg'].CFrame*CFrame.new(0*math.sin(doog/0.1),5*math.cos(doog/0.1),0*math.cos(doog/0.1))
char['Left Leg'].Velocity = Vector3.new(60000,60000,-600000)
else
char['Left Leg'].AssemblyLinearVelocity = Vector3.new(0,30,0)
end
end))

coroutine.wrap(function()
while true do -- anim changer
if HumanDied then run:Disconnect() run1:Disconnect() atk:Disconnect() break end
sine = sine + speed
local rlegray = Ray.new(reanim["Right Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, char)
local llegray = Ray.new(reanim["Left Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, char)
local rightvector = (Root.Velocity * Root.CFrame.rightVector).X + (Root.Velocity * Root.CFrame.rightVector).Z
local lookvector = (Root.Velocity * Root.CFrame.lookVector).X + (Root.Velocity * Root.CFrame.lookVector).Z
if lookvector > reanim.Humanoid.WalkSpeed then
lookvector = reanim.Humanoid.WalkSpeed
end
if lookvector < -reanim.Humanoid.WalkSpeed then
lookvector = -reanim.Humanoid.WalkSpeed
end
if rightvector > reanim.Humanoid.WalkSpeed then
rightvector = reanim.Humanoid.WalkSpeed
end
if rightvector < -reanim.Humanoid.WalkSpeed then
rightvector = -reanim.Humanoid.WalkSpeed
end
local lookvel = lookvector / reanim.Humanoid.WalkSpeed
local rightvel = rightvector / reanim.Humanoid.WalkSpeed
if Mode == 'Normal' then
if Root.Velocity.y > 1 then -- jump
--jump clerp here
elseif Root.Velocity.y < -1 then -- fall
--fall clerp here
elseif Root.Velocity.Magnitude < 2 then -- idle
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),2+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.sin(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),3+0.3*math.cos(sine/15),0+0*math.cos(sine/13))*ANGLES(RAD(0+5*math.sin(sine/111)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(2.5+0*math.cos(sine/13),1.2+-0.3*math.sin(sine/131),0+0*math.cos(sine/13))*ANGLES(RAD(-5+8*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(10+0*math.cos(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-2.5+0*math.cos(sine/13),1.2+-0.3*math.sin(sine/131),0+0*math.cos(sine/13))*ANGLES(RAD(-5+8*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-10+0*math.cos(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(1.2+0*math.cos(sine/13),-2.4+-0.4*math.cos(sine/999),-0.2+0*math.cos(sine/13))*ANGLES(RAD(0+-10*math.sin(sine/100)),RAD(-10+0*math.cos(sine/13)),RAD(5+0*math.sin(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-1.2+0*math.cos(sine/13),-2.4+-0.4*math.cos(sine/999),-0.2+0*math.cos(sine/13))*ANGLES(RAD(0+-10*math.sin(sine/100)),RAD(10+0*math.cos(sine/13)),RAD(-5+0*math.sin(sine/13))),.3)
elseif Root.Velocity.Magnitude < 20 then -- walk
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),2+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))-Root.Velocity.Y/50,RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/4),3+0.3*math.cos(sine/4),0+0*math.cos(sine/4))*ANGLES(RAD(-15+5*math.sin(sine/4))*lookvel,RAD(0+0*math.cos(sine/4)),RAD(-15+5*math.sin(sine/4))*rightvel),.3)
RS.C0 = RS.C0:Lerp(CF(2.5+0*math.cos(sine/8),1+0*math.cos(sine/8),0+0*math.cos(sine/8))*ANGLES(RAD(0+60*math.sin(sine/8))*lookvel,RAD(0+0*math.sin(sine/8)),RAD(0+0*math.cos(sine/8))*rightvel),.3)
LS.C0 = LS.C0:Lerp(CF(-2.5+0*math.cos(sine/8),1+0*math.cos(sine/8),0+0*math.cos(sine/8))*ANGLES(RAD(0+-60*math.sin(sine/8))*lookvel,RAD(0+0*math.sin(sine/8)),RAD(0+0*math.cos(sine/8))*rightvel),.3)
RH.C0 = RH.C0:Lerp(CF(1+0*math.cos(sine/8),-2.5+-1*math.cos(sine/8),-0.5*1+0.5*math.cos(sine/8)*lookvel)*ANGLES(RAD(0+-50*math.sin(sine/8))*lookvel,RAD(0+0*math.cos(sine/8)),RAD(0-25*math.sin(sine/8))*rightvel),.3)
LH.C0 = LH.C0:Lerp(CF(-1+0*math.cos(sine/8),-2.5+1*math.cos(sine/8),-0.5*1-0.5*math.cos(sine/8)*lookvel)*ANGLES(RAD(0+50*math.sin(sine/8))*lookvel,RAD(0+0*math.cos(sine/8)),RAD(0+25*math.sin(sine/8))*rightvel),.3)
elseif Root.Velocity.Magnitude > 20 then -- run
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),2+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/2.5),3+0.4*math.cos(sine/2.5),0+0*math.cos(sine/2.5))*ANGLES(RAD(-25+5*math.sin(sine/2.5))*lookvel,RAD(0+0*math.cos(sine/2.5)),RAD(-15+5*math.sin(sine/2.5))*rightvel),.3)
RS.C0 = RS.C0:Lerp(CF(2.5+0*math.cos(sine/5),1+0*math.cos(sine/5),0+0*math.cos(sine/5))*ANGLES(RAD(90*math.sin(sine/5))*lookvel,RAD(0+0*math.cos(sine/5)),RAD(0+0*math.cos(sine/5))*rightvel),.3)
LS.C0 = LS.C0:Lerp(CF(-2.5+0*math.cos(sine/5),1+0*math.cos(sine/5),0+0*math.cos(sine/5))*ANGLES(RAD(-90*math.sin(sine/5))*lookvel,RAD(0+0*math.cos(sine/5)),RAD(0+0*math.cos(sine/5))*rightvel),.3)
RH.C0 = RH.C0:Lerp(CF(1+0*math.cos(sine/5),-2.5*1+-1*math.cos(sine/5),-0.5*1+0.5*math.cos(sine/5)*lookvel)*ANGLES(RAD(-70*math.sin(sine/5))*lookvel,RAD(0+0*math.cos(sine/5)),RAD(0+-55*math.sin(sine/5))*rightvel),.3)
LH.C0 = LH.C0:Lerp(CF(-1+0*math.cos(sine/5),-2.5*1+1*math.cos(sine/5),-0.5*1+-0.5*math.cos(sine/5)*lookvel)*ANGLES(RAD(70*math.sin(sine/5))*lookvel,RAD(0+0*math.cos(sine/5)),RAD(0+55*math.sin(sine/5))*rightvel),.3)
end
elseif Mode == 'Stomp0' then
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),2+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),2.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(15+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(2.5+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(75+0*math.cos(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-2.5+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-50+0*math.cos(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(1+0*math.cos(sine/13),-2.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-50+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-1+0*math.cos(sine/13),-0.5+0*math.cos(sine/13),-1.5+0*math.cos(sine/13))*ANGLES(RAD(-5+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
elseif Mode == 'Stomp1' then
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),2+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-10+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-25+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
RS.C0 = RS.C0:Lerp(CF(2.5+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-65+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(25+0*math.cos(sine/13))),.3)
LS.C0 = LS.C0:Lerp(CF(-2.5+0*math.cos(sine/13),1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-170+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(-30+0*math.cos(sine/13))),.3)
RH.C0 = RH.C0:Lerp(CF(1+0*math.cos(sine/13),-2.5+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(-170+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
LH.C0 = LH.C0:Lerp(CF(-1+0*math.cos(sine/13),1+0*math.cos(sine/13),-1.5+0*math.cos(sine/13))*ANGLES(RAD(25+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.cos(sine/13))),.3)
end
srv.RenderStepped:Wait()
end
end)()
end)


local FirstPage = MainUI.AddPage("(Not Working)")
local FirstLabel = FirstPage.AddLabel("Fe")

local FirstButton = FirstPage.AddButton("Void Scythe", function()
local A_1 = ";morph me Slender "
local Event = game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand
Event:InvokeServer(A_1)
 
local A_1 = "Authenticate"
local Event = game:GetService("Workspace").Boards.SettingsHandler.Retriever
Event:InvokeServer(A_1)
 
local A_1 = ";morph me Noob1 "
local Event = game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand
Event:InvokeServer(A_1)
 
local A_1 = ";char me nato1231231Qw"
local Event = game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand
Event:InvokeServer(A_1)
    wait(1)

    local args = {
        [1] = ";hat me 5414429551"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(.8)

    loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/lib/Reanimate.lua"))()
wait(1)
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/scripts/VoidScythe.lua"))()

end)

local FirstButton = FirstPage.AddButton("Quenox", function()
local A_1 = ";morph me Slender "
local Event = game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand
Event:InvokeServer(A_1)
 
local A_1 = "Authenticate"
local Event = game:GetService("Workspace").Boards.SettingsHandler.Retriever
Event:InvokeServer(A_1)
 
local A_1 = ";morph me Noob1 "
local Event = game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand
Event:InvokeServer(A_1)
 
local A_1 = ";char me nato1231231Qw"
local Event = game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand
Event:InvokeServer(A_1)
    wait(1)

        local args = {
        [1] = ";hat me 4820152700"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(.8)

        local args = {
        [1] = ";hat me 4794315940"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(.8)

        local args = {
        [1] = ";hat me 4524991457"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(.8)

        local args = {
        [1] = ";hat me 4315489767"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(.8)

        local args = {
        [1] = ";hat me 4506945409"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(.8)

        local args = {
        [1] = ";hat me 4458601937"
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    wait(.8)

    loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/lib/Reanimate.lua"))()
wait(.8)
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/scripts/Quenox.lua"))()

end)


local FirstPage = MainUI.AddPage("Radio")

local FirstLabel = FirstPage.AddLabel("For Radio")

local FirstButton = FirstPage.AddButton("Start Dubbing", function()
    _G.Drop = true
    while _G.Drop == true do
        game.Players.LocalPlayer.Backpack:FindFirstChildOfClass("Tool").Parent = game.Players.LocalPlayer.Character
    wait()
    game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool").Parent = game.Workspace
    local args = {
        [1] = ";re"
    }
    
    game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))
    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(game.Players.LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, 10, 0))
    wait(1.1)
end  
end)

local FirstButton = FirstPage.AddButton("Stop Dubbing", function()
    _G.Drop = false
end)

local FirstButton = FirstPage.AddButton("Visible", function()
local args = {
        [1] = ";visible "
    }
game:GetService("ReplicatedStorage").HDAdminClient.Signals.RequestCommand:InvokeServer(unpack(args))    
end)


local FirstLabel = FirstPage.AddLabel("Radio")

local FirstButton = FirstPage.AddButton("PP (7 Tools)", function()
    local plr = game:GetService("Players").LocalPlayer; plr.Character.Humanoid:UnequipTools()
	local Tools = plr.Backpack:GetChildren()
   
	Tools[1].Grip = CFrame.new(0.2, 1.6, 1.5) * CFrame.Angles(0, math.rad(-90), 0)
	Tools[1].Parent = plr.Character
	
    Tools[2].Grip = CFrame.new(-1.4, 1.6, 1.5) * CFrame.Angles(0, math.rad(-90), 0)
	Tools[2].Parent = plr.Character
	
	Tools[3].Grip = CFrame.new(-3.0, 1.6, 1.5) * CFrame.Angles(0, math.rad(-90), 0)
	Tools[3].Parent = plr.Character
	
	Tools[4].Grip = CFrame.new(-4.6, 1.6, 1.5) * CFrame.Angles(0, math.rad(-90), 0)
	Tools[4].Parent = plr.Character
	
	Tools[5].Grip = CFrame.new(-6.3, 1.6, 1.5) * CFrame.Angles(0, math.rad(-90), 0)
	Tools[5].Parent = plr.Character
	
	Tools[6].Grip = CFrame.new(-8.0, 1.6, 1.5) * CFrame.Angles(0, math.rad(-90), 0)
	Tools[6].Parent = plr.Character
	
	Tools[7].Grip = CFrame.new(-1.5, 2.0, 1.0) * CFrame.Angles(0, math.rad(-180), 0)
	Tools[7].Parent = plr.Character
	
end)

local FirstButton = FirstPage.AddButton("AK-47 (20 Tools)", function()
 local plr = game:GetService("Players").LocalPlayer; plr.Character.Humanoid:UnequipTools()
 local Tools = plr.Backpack:GetChildren()

 Tools[1].Grip = CFrame.new(0.7, -0.5, -0.2) * CFrame.Angles(50, math.rad(-180), 3.13)
 Tools[1].Parent = plr.Character

 Tools[2].Grip = CFrame.new(0.5, -1.2, -0.2) * CFrame.Angles(0, math.rad(-90), 0)
 Tools[2].Parent = plr.Character

 Tools[3].Grip = CFrame.new(-1.5, -1.2, -0.2) * CFrame.Angles(0, math.rad(-90), 0.03)
 Tools[3].Parent = plr.Character

 Tools[4].Grip = CFrame.new(-2.5, -1.2, -0.2) * CFrame.Angles(0, math.rad(-90), 0)
 Tools[4].Parent = plr.Character

 Tools[5].Grip = CFrame.new(-4.6, -0.4, -0.2) * CFrame.Angles(1.6, math.rad(-98), 1.6)
 Tools[5].Parent = plr.Character

 Tools[6].Grip = CFrame.new(-7, -1.2, -0.2) * CFrame.Angles(0, math.rad(-90), 0)
 Tools[6].Parent = plr.Character

 Tools[7].Grip = CFrame.new(-9.2, -1.2, -0.2) * CFrame.Angles(0, math.rad(-90), 0)
 Tools[7].Parent = plr.Character

 Tools[8].Grip = CFrame.new(-11, -1.2, -0.2) * CFrame.Angles(0, math.rad(-90), 0)
 Tools[8].Parent = plr.Character

 Tools[9].Grip = CFrame.new(-1.2, -3.1, -0.2) * CFrame.Angles(1.6, math.rad(-15), 1.6)
 Tools[9].Parent = plr.Character

 Tools[10].Grip = CFrame.new(-3.3, -2.7, -0.2) * CFrame.Angles(1.6, math.rad(-25), 1.6)
 Tools[10].Parent = plr.Character

 Tools[11].Grip = CFrame.new(-0.1, 1.8, -0.1) * CFrame.Angles(1.6, math.rad(65), 1.6)
 Tools[11].Parent = plr.Character

 Tools[12].Grip = CFrame.new(1.3, 2.05, -0.1) * CFrame.Angles(1.6, math.rad(90), 1.6)
 Tools[12].Parent = plr.Character

 Tools[13].Grip = CFrame.new(3.15, 2.05, -0.1) * CFrame.Angles(1.6, math.rad(90), 1.6)
 Tools[13].Parent = plr.Character

 Tools[14].Grip = CFrame.new(5.3, 2.05, -0.1) * CFrame.Angles(1.6, math.rad(90), 1.6)
 Tools[14].Parent = plr.Character

 Tools[15].Grip = CFrame.new(6.5, 4.1, -0.1) * CFrame.Angles(1.6, math.rad(110), 1.6)
 Tools[15].Parent = plr.Character

 Tools[16].Grip = CFrame.new(-12.5, -1.2, -0.2) * CFrame.Angles(0, math.rad(-90), 0)
 Tools[16].Parent = plr.Character

 Tools[17].Grip = CFrame.new(3.1, -1.2, -0.2) * CFrame.Angles(0, math.rad(-90), 0)
 Tools[17].Parent = plr.Character

 Tools[18].Grip = CFrame.new(5.2, -1.2, -0.2) * CFrame.Angles(0, math.rad(-90), 0)
 Tools[18].Parent = plr.Character

 Tools[19].Grip = CFrame.new(0.25, 6.8, -0.05) * CFrame.Angles(1.6, math.rad(-0), 1.6)
 Tools[19].Parent = plr.Character

 Tools[20].Grip = CFrame.new(3.8, -4.4, -0.27) * CFrame.Angles(1.6, math.rad(-137), 1.6)
 Tools[20].Parent = plr.Character
end)

local FirstButton = FirstPage.AddButton("AK-47 (2) (15 Tools)", function()
 local plr = game:GetService("Players").LocalPlayer; plr.Character.Humanoid:UnequipTools()
 local Tools = plr.Backpack:GetChildren()

 Tools[1].Grip = CFrame.new(0.7, -0.5, -0.2) * CFrame.Angles(50, math.rad(-180), 3.13)
 Tools[1].Parent = plr.Character

 Tools[2].Grip = CFrame.new(0.5, -1.2, -0.2) * CFrame.Angles(0, math.rad(-90), 0)
 Tools[2].Parent = plr.Character

 Tools[3].Grip = CFrame.new(-1.5, -1.2, -0.2) * CFrame.Angles(0, math.rad(-90), 0.03)
 Tools[3].Parent = plr.Character

 Tools[4].Grip = CFrame.new(-2.5, -1.2, -0.2) * CFrame.Angles(0, math.rad(-90), 0)
 Tools[4].Parent = plr.Character

 Tools[5].Grip = CFrame.new(-4.6, -0.4, -0.2) * CFrame.Angles(1.6, math.rad(-98), 1.6)
 Tools[5].Parent = plr.Character

 Tools[6].Grip = CFrame.new(-7, -1.2, -0.2) * CFrame.Angles(0, math.rad(-90), 0)
 Tools[6].Parent = plr.Character

 Tools[7].Grip = CFrame.new(-9.2, -1.2, -0.2) * CFrame.Angles(0, math.rad(-90), 0)
 Tools[7].Parent = plr.Character

 Tools[8].Grip = CFrame.new(-11, -1.2, -0.2) * CFrame.Angles(0, math.rad(-90), 0)
 Tools[8].Parent = plr.Character

 Tools[9].Grip = CFrame.new(-1.2, -3.1, -0.2) * CFrame.Angles(1.6, math.rad(-15), 1.6)
 Tools[9].Parent = plr.Character

 Tools[10].Grip = CFrame.new(-3.3, -2.7, -0.2) * CFrame.Angles(1.6, math.rad(-25), 1.6)
 Tools[10].Parent = plr.Character

 Tools[11].Grip = CFrame.new(-0.1, 1.8, -0.1) * CFrame.Angles(1.6, math.rad(65), 1.6)
 Tools[11].Parent = plr.Character

 Tools[12].Grip = CFrame.new(1.3, 2.05, -0.1) * CFrame.Angles(1.6, math.rad(90), 1.6)
 Tools[12].Parent = plr.Character

 Tools[13].Grip = CFrame.new(3.15, 2.05, -0.1) * CFrame.Angles(1.6, math.rad(90), 1.6)
 Tools[13].Parent = plr.Character

 Tools[14].Grip = CFrame.new(5.3, 2.05, -0.1) * CFrame.Angles(1.6, math.rad(90), 1.6)
 Tools[14].Parent = plr.Character

 Tools[15].Grip = CFrame.new(6.5, 4.1, -0.1) * CFrame.Angles(1.6, math.rad(110), 1.6)
 Tools[15].Parent = plr.Character
end)


local FirstPage = MainUI.AddPage("Creadits")
local FirstLabel = FirstPage.AddLabel("Discord | ! SNOOBE#8044")
local FirstLabel = FirstPage.AddLabel("Roblox | S_Zow , X_akp")
